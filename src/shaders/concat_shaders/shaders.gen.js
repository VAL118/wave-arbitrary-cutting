window.VRC.Core.prototype._shaders.firstPass = {
	uniforms: THREE.UniformsUtils.merge([
		{
		}
	]),
	vertexShader: [
		'varying vec3 worldSpaceCoords;',
		'void main()',
		'{',
		'    //Set the world space coordinates of the back faces vertices as output.',
		'    worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]',
		'    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'}  '].join("\n"),
	fragmentShader: [
		'varying vec3 worldSpaceCoords;',
		'void main() {',
		'    //The fragment\'s world space coordinates as fragment output.',
		'    gl_FragColor = vec4( worldSpaceCoords.x , worldSpaceCoords.y, worldSpaceCoords.z, 1 );',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassBilinearRGB = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uTransferFunction" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uColorVal" : { type: "f", value: -1 },
		"uAbsorptionModeIndex" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"uSteps" : { type: "f", value: -1 },
		"uRatio" : { type: "f", value: -1 },
		"uAvailable_textures_number" : { type: "i", value: 0 },
		}
	]),
	vertexShader: [
		'varying vec3 worldSpaceCoords;',
		'varying vec4 projectedCoords;',
		' ',
		'void main()',
		'{',
		'    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;',
		'    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'}'].join("\n"),
	fragmentShader: [
		'#ifdef GL_FRAGMENT_PRECISION_HIGH ',
		' // highp is supported ',
		' precision highp int; ',
		' precision highp float; ',
		'#else ',
		' // high is not supported ',
		' precision mediump int; ',
		' precision mediump float; ',
		'#endif ',
		'// Passed from vertex',
		'varying vec3 worldSpaceCoords; ',
		'varying vec4 projectedCoords; ',
		'// Passed from core',
		'uniform sampler2D uBackCoord; ',
		'uniform sampler2D uTransferFunction;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uSlicemapWidth;',
		'// Assuming a bounding box of 512x512x512',
		'// ceil( sqrt(3) * 512 ) = 887',
		'const int MAX_STEPS = 887;',
		'// Application specific parameters',
		'uniform float uNumberOfSlices; ',
		'uniform float uMinGrayVal; ',
		'uniform float uMaxGrayVal;',
		'uniform float uOpacityVal; ',
		'uniform float uColorVal; ',
		'uniform float uAbsorptionModeIndex;',
		'uniform float uSlicesOverX; ',
		'uniform float uSlicesOverY; ',
		'uniform float uSteps;',
		'uniform float uRatio;',
		'// uniform int uAvailable_textures_number;',
		'vec4 getVolumeValue(vec3 volpos)',
		'{',
		'    //if (volpos.z < 0.5)',
		'    //    return vec4(0.0);',
		'    float s1Original, s2Original, s1, s2; ',
		'    float dx1, dy1; ',
		'    float dx2, dy2; ',
		'    // float value; ',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float delta = 1.0 / (sliceSizeX * uRatio);',
		'    ',
		'    float adapted_x, adapted_y, adapted_z;',
		'    //adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;',
		'    //adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;',
		'    //adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);',
		'    ',
		'    adapted_x = volpos.x;',
		'    adapted_y = volpos.y;',
		'    //adapted_z = volpos.z;',
		'    adapted_z = 1.0 - (volpos.z * (1.0/uRatio));',
		'    s1Original = floor(adapted_z * uNumberOfSlices);',
		'    s2Original = s1Original + delta;',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    int tex2Index = int(floor(s2Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    s2 = mod(s2Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    dx2 = fract(s2/uSlicesOverX);',
		'    dy2 = floor(s2/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    texpos1.x = dx1+(adapted_x*sliceSizeX)/uSlicemapWidth;',
		'    texpos1.y = dy1+(adapted_y*sliceSizeY)/uSlicemapWidth;',
		'    ',
		'    texpos2.x = dx2+(adapted_x*sliceSizeX)/uSlicemapWidth;',
		'    texpos2.y = dy2+(adapted_y*sliceSizeY)/uSlicemapWidth;',
		' ',
		' ',
		'    vec4 value1, value2;',
		'    ',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'        if( tex2Index == <%=i%> )',
		'        {',
		'            value2 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'    <% } %>',
		'    ',
		'    //return vec4( (value1 + value2) * 0.5);',
		'    ',
		'    ',
		'    return mix(value1, value2, fract(volpos.z* uNumberOfSlices));',
		'}',
		'void main(void) {',
		' ',
		'    //Transform the coordinates it from [-1;1] to [0;1]',
		'    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,',
		'                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);',
		'    //The back position is the world space position stored in the texture.',
		'    vec3 backPos = texture2D(uBackCoord, texc).xyz;',
		'                ',
		'    //The front position is the world space position of the second render pass.',
		'    vec3 frontPos = worldSpaceCoords;',
		' ',
		'    //The direction from the front position to back position.',
		'    vec3 dir = backPos - frontPos;',
		'    float rayLength = length(dir);',
		'    //Calculate how long to increment in each step.',
		'    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;',
		'    //float steps = 256.0;',
		'    float delta = 1.0 / steps;',
		'    ',
		'    //The increment in each direction for each step.',
		'    vec3 deltaDirection = normalize(dir) * delta;',
		'    ',
		'    vec3 Step = dir / steps;',
		'    ',
		'    float deltaDirectionLength = length(deltaDirection);',
		'    //vec4 vpos = frontColor;  // currentPosition',
		'    //vec3 Step = dir/uStepsF; // steps',
		'    //Start the ray casting from the front position.',
		'    vec3 currentPosition = frontPos;',
		'    //The color accumulator.',
		'    vec4 accumulatedColor = vec4(0.0);',
		'    //The alpha value accumulated so far.',
		'    float accumulatedAlpha = 0.0;',
		'    ',
		'    //How long has the ray travelled so far.',
		'    float accumulatedLength = 0.0;',
		'    ',
		'    //If we have twice as many samples, we only need ~1/2 the alpha per sample.',
		'    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.',
		'    float alphaScaleFactor = 28.8 * delta;',
		'    ',
		'    vec4 colorSample = vec4(0.0);',
		'    vec4 sample = vec4(0.0); ',
		'    vec4 grayValue;',
		'    float alphaSample;',
		'    float alphaCorrection = 1.0;',
		'    ',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float sm_delta = 1.0 / sliceSizeX;',
		'    ',
		'    //Perform the ray marching iterations',
		'    for(int i = 0; i < MAX_STEPS; i++) {       ',
		'        if(currentPosition.x > 1.0 ||',
		'           currentPosition.y > 1.0 ||',
		'           currentPosition.z > 1.0 ||',
		'           currentPosition.x < 0.0 ||',
		'           currentPosition.y < 0.0 ||',
		'           currentPosition.z < 0.0)',
		'            break;',
		'        if(accumulatedColor.a>=1.0) ',
		'            break;',
		'        grayValue = getVolumeValue(currentPosition); ',
		'        if(grayValue.z < 0.05 || ',
		'           grayValue.x <= 0.0 ||',
		'           grayValue.x >= 1.0)  ',
		'            accumulatedColor = vec4(0.0);     ',
		'        else { ',
		'            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;',
		'            colorSample.xyz = grayValue.xyz;',
		'            //colorSample.w = alphaScaleFactor;',
		'            colorSample.w = 0.1;',
		'              ',
		'            //sample.a = colorSample.a * 40.0 * (1.0 / steps);',
		'            sample.a = colorSample.a;',
		'            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xyz * sample.a; ',
		'             ',
		'            accumulatedColor += sample; ',
		'        }    ',
		'   ',
		'        //Advance the ray.',
		'        //currentPosition.xyz += deltaDirection;',
		'        currentPosition.xyz += Step;',
		'   ',
		'         ',
		'    } ',
		'    gl_FragColor = accumulatedColor;',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassFusion = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"darkness" : { type: "f", value: -1 },
		"minSos" : { type: "f", value: -1 },
		"minRefl" : { type: "f", value: -1 },
		"minAtten" : { type: "f", value: -1 },
		"maxSos" : { type: "f", value: -1 },
		"maxRefl" : { type: "f", value: -1 },
		"maxAtten" : { type: "f", value: -1 },
		"l" : { type: "f", value: -1 },
		"s" : { type: "f", value: -1 },
		"hMin" : { type: "f", value: -1 },
		"hMax" : { type: "f", value: -1 },
		}
	]),
	vertexShader: [
		'precision mediump int; ',
		'precision mediump float; ',
		'attribute vec4 vertColor; ',
		'varying vec4 frontColor; ',
		'varying vec4 pos; ',
		'void main(void) ',
		'{ ',
		'    frontColor = vertColor; ',
		'    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ',
		'    gl_Position = pos; ',
		'} '].join("\n"),
	fragmentShader: [
		'precision mediump int;',
		'precision mediump float;',
		'varying vec4 frontColor;',
		'varying vec4 pos;',
		'uniform sampler2D uBackCoord;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uNumberOfSlices;',
		'uniform float uOpacityVal;',
		'uniform float uSlicesOverX;',
		'uniform float uSlicesOverY;',
		'uniform float darkness;',
		'uniform float minSos;',
		'uniform float minRefl;',
		'uniform float minAtten;',
		'uniform float maxSos;',
		'uniform float maxRefl;',
		'uniform float maxAtten;',
		'uniform float l;',
		'uniform float s;',
		'uniform float hMin;',
		'uniform float hMax;',
		'//Acts like a texture3D using Z slices and trilinear filtering.',
		'vec3 getVolumeValue(vec3 volpos)',
		'{',
		'    float s1Original, s2Original, s1, s2;',
		'    float dx1, dy1;',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    s1Original = floor(volpos.z*uNumberOfSlices);',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    texpos1.x = dx1+(volpos.x/uSlicesOverX);',
		'    texpos1.y = dy1+(volpos.y/uSlicesOverY);',
		'    vec3 value = vec3(0.0,0.0,0.0);',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;',
		'        }',
		'        <% if( i < maxTexturesNumber-1 ) { %>',
		'            else',
		'        <% } %>',
		'    <% } %>',
		'    return value;',
		'}',
		'// x - R, y - G, z - B',
		'// x - H, y - S, z - V',
		'vec3 hsv2rgb(vec3 hsv)',
		'{',
		'    float     hue, p, q, t, ff;',
		'    int        i;',
		'    hsv.z = (darkness - hsv.z) * l;',
		'    hsv.x = (hsv.x - hMin)/(hMax - hMin) * 360.0;',
		'    hsv.y *= s * 1.5;',
		'    hue=hsv.x >= 360.0?hsv.x-360.0:hsv.x;',
		'    hue /= 60.0;',
		'    i = int(hue);',
		'    ff = hue - float(i);',
		'    p = hsv.z * (1.0 - hsv.y);',
		'    q = hsv.z * (1.0 - (hsv.y * ff));',
		'    t = hsv.z * (1.0 - (hsv.y * (1.0 - ff)));',
		'    if(i==0)',
		'        return vec3(hsv.z,t,p);',
		'    else if(i==1)',
		'      return vec3(q,hsv.z,p);',
		'    else if(i==2)',
		'        return vec3(p,hsv.z,t);',
		'    else if(i==3)',
		'        return vec3(p,q,hsv.z);',
		'    else if(i==4)',
		'        return vec3(t,p,hsv.z);',
		'    else',
		'        return vec3(hsv.z,p,q);',
		'}',
		'void main(void)',
		'{',
		' const int uStepsI = 144;',
		' const float uStepsF = float(uStepsI);',
		' vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0;',
		' vec4 backColor = texture2D(uBackCoord,texC);',
		' vec3 dir = backColor.rgb - frontColor.rgb;',
		' vec4 vpos = frontColor;',
		' vec3 Step = dir/uStepsF;',
		' vec4 accum = vec4(0, 0, 0, 0);',
		' vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);',
		' vec4 colorValue = vec4(0, 0, 0, 0);',
		' float opacityFactor = uOpacityVal;',
		' for(int i = 0; i < uStepsI; i++)',
		' {',
		'    vec3 gray_val = getVolumeValue(vpos.xyz);',
		'     if(gray_val.z < 0.05 ||',
		'         gray_val.x < minSos ||',
		'         gray_val.x > maxSos ||',
		'         gray_val.y < minAtten ||',
		'         gray_val.y > maxAtten ||',
		'         gray_val.z < minRefl ||',
		'         gray_val.z > maxRefl',
		'       )',
		'         colorValue = vec4(0.0);',
		'     else {',
		'            colorValue.x = gray_val.x;',
		'            colorValue.y = 1.0-gray_val.y/0.6;',
		'            colorValue.z = gray_val.z;',
		'            colorValue.w = 0.1;',
		'            // colorValue.x = gray_val.z;',
		'            // colorValue.y = gray_val.z;',
		'            // colorValue.z = gray_val.z;',
		'            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF);',
		'            sample.rgb = (1.0 - accum.a) * hsv2rgb(colorValue.rgb) * sample.a;',
		'            accum += sample;',
		'            if(accum.a>=1.0)',
		'               break;',
		'     }',
		'     //advance the current position',
		'     vpos.xyz += Step;',
		'   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)',
		'         break;',
		' }',
		' gl_FragColor = accum;',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassGraySeparate = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"minSos" : { type: "f", value: -1 },
		"minRefl" : { type: "f", value: -1 },
		"minAtten" : { type: "f", value: -1 },
		"maxSos" : { type: "f", value: -1 },
		"maxRefl" : { type: "f", value: -1 },
		"maxAtten" : { type: "f", value: -1 },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"uIndexOfImage" : { type: "i", value: 0 },
		"uOutlineOpacity" : { type: "f", value: -1 },
		"uSosOpacity" : { type: "f", value: -1 },
		"uAttenOpacity" : { type: "f", value: -1 },
		"uSurfaceThresholdBot" : { type: "f", value: -1 },
		"uSurfaceThresholdTop" : { type: "f", value: -1 },
		"uSosThresholdBot" : { type: "f", value: -1 },
		"uSosThresholdTop" : { type: "f", value: -1 },
		"uAttenThresholdBot" : { type: "f", value: -1 },
		"uAttenThresholdTop" : { type: "f", value: -1 },
		"uEnableOverlap" : { type: "i", value: 0 },
		"l" : { type: "f", value: -1 },
		"s" : { type: "f", value: -1 },
		"hMin" : { type: "f", value: -1 },
		"hMax" : { type: "f", value: -1 },
		"darkness" : { type: "f", value: -1 },
		}
	]),
	vertexShader: [
		'precision mediump int;',
		'precision mediump float;',
		'attribute vec4 vertColor;',
		'varying vec4 frontColor;',
		'varying vec4 pos;',
		'void main(void)',
		'{',
		'    frontColor = vertColor;',
		'    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
		'    gl_Position = pos; ',
		'}'].join("\n"),
	fragmentShader: [
		'precision mediump int;',
		'precision mediump float;',
		'varying vec4 frontColor;',
		'varying vec4 pos;',
		'uniform sampler2D uBackCoord;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uNumberOfSlices;',
		'uniform float uOpacityVal;',
		'uniform float uSlicesOverX;',
		'uniform float uSlicesOverY;',
		'uniform float minSos;',
		'uniform float minRefl;',
		'uniform float minAtten;',
		'uniform float maxSos;',
		'uniform float maxRefl;',
		'uniform float maxAtten;',
		'uniform float uSlicemapWidth;',
		'uniform int uIndexOfImage;',
		'uniform float uOutlineOpacity;',
		'uniform float uSosOpacity;',
		'uniform float uAttenOpacity;',
		'uniform float uSurfaceThresholdBot;',
		'uniform float uSurfaceThresholdTop;',
		'uniform float uSosThresholdBot;',
		'uniform float uSosThresholdTop;',
		'uniform float uAttenThresholdBot;',
		'uniform float uAttenThresholdTop;',
		'uniform bool uEnableOverlap;',
		'/////////////////for HSV2RGB',
		'uniform float l;',
		'uniform float s;',
		'uniform float hMin;',
		'uniform float hMax;',
		'uniform float darkness;',
		'///////////////////////////',
		'//Acts like a texture3D using Z slices and trilinear filtering.',
		'vec3 getVolumeValue(vec3 volpos) {',
		'  // float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'  // float delta = 1.0 / sliceSizeX;',
		'  // float  adapted_z = (((volpos.z) * (1.0 - (2.0*delta))) + delta);',
		'  // s1Original = floor(adapted_z*uNumberOfSlices);',
		'  float s1Original, s2Original, s1, s2;',
		'  float dx1, dy1;',
		'  vec2 texpos1,texpos2;',
		'  float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'  s1Original = floor(volpos.z*(uNumberOfSlices));',
		'  int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'  s1 = mod(s1Original, slicesPerSprite);',
		'  dx1 = fract(s1/uSlicesOverX);',
		'  dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'  texpos1.x = dx1+(volpos.x/uSlicesOverX);',
		'  texpos1.y = dy1+(volpos.y/uSlicesOverY);',
		'  vec3 value = vec3(0.0,0.0,0.0);',
		'  <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'      if( tex1Index == <%=i%> )',
		'      {',
		'          value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;',
		'      }',
		'      <% if( i < maxTexturesNumber-1 ) { %>',
		'          else',
		'      <% } %>',
		'  <% } %>',
		'  return value;',
		'}',
		'vec3 hsv2rgb(vec3 hsv)',
		'{',
		'    float     hue, p, q, t, ff;',
		'    int        i;',
		'    hsv.z = (darkness - hsv.z) * l;',
		'    hsv.x = (hsv.x - hMin)/(hMax - hMin) * 360.0;',
		'    hsv.y *= s * 1.5;',
		'    hue=hsv.x >= 360.0?hsv.x-360.0:hsv.x;',
		'    hue /= 60.0;',
		'    i = int(hue);',
		'    ff = hue - float(i);',
		'    p = hsv.z * (1.0 - hsv.y);',
		'    q = hsv.z * (1.0 - (hsv.y * ff));',
		'    t = hsv.z * (1.0 - (hsv.y * (1.0 - ff)));',
		'    if(i==0)',
		'        return vec3(hsv.z,t,p);',
		'    else if(i==1)',
		'      return vec3(q,hsv.z,p);',
		'    else if(i==2)',
		'        return vec3(p,hsv.z,t);',
		'    else if(i==3)',
		'        return vec3(p,q,hsv.z);',
		'    else if(i==4)',
		'        return vec3(t,p,hsv.z);',
		'    else',
		'        return vec3(hsv.z,p,q);',
		'}',
		'void main(void)',
		'{',
		' const int uStepsI = 144;',
		' const float uStepsF = float(uStepsI);',
		' vec2 texC = vec2((pos.xy/pos.w) + 1.0) / 2.0;',
		' vec4 backColor = texture2D(uBackCoord,texC);',
		' vec3 dir = backColor.rgb - frontColor.rgb;',
		' // vec3 dir = vec3(0.0,0.0,0.0);',
		' vec4 vpos = frontColor;',
		' vec3 Step = dir/uStepsF;',
		' vec4 accum = vec4(0, 0, 0, 0);',
		' vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);',
		' vec4 colorValue = vec4(0, 0, 0, 0);',
		' float opacityFactor = uOpacityVal;',
		' float surfaceThresholdBot = uSurfaceThresholdBot;',
		' float surfaceThresholdTop = uSurfaceThresholdTop;',
		' float sosThresholdBot = uSosThresholdBot;',
		' float sosThresholdTop = uSosThresholdTop;',
		' float attenThresholdBot = uAttenThresholdBot;',
		' float attenThresholdTop = uAttenThresholdTop;',
		' // float outlineOpacity = uOutlineOpacity;',
		' float outlineOpacity = 0.1;',
		' // float sosOpacity = uSosOpacity;',
		' float sosOpacity = 0.1;',
		' // float attenOpacity = uAttenOpacity;',
		' float attenOpacity = 0.1;',
		' for(int i = 0; i < uStepsI; i++)',
		' {',
		'    vec3 gray_val = getVolumeValue(vpos.xyz);',
		'     if(gray_val.z < 0.05 ||',
		'         gray_val.x < minSos ||',
		'         gray_val.x > maxSos ||',
		'         gray_val.y < minAtten ||',
		'         gray_val.y > maxAtten ||',
		'         gray_val.z < minRefl ||',
		'         gray_val.z > maxRefl',
		'       )',
		'         colorValue = vec4(0.0);',
		'     else',
		'     {',
		'        colorValue.a = outlineOpacity; //получили opacity для всего изображения',
		'        {',
		'          if (uIndexOfImage==0) //only sos',
		'          {',
		'            colorValue.x = gray_val.y;',
		'            colorValue.y = 1.0-gray_val.y/0.7;',
		'            colorValue.z = gray_val.y/1.8;',
		'          }',
		'          if (uIndexOfImage==1) //only atten',
		'          {',
		'            colorValue.x = gray_val.x;',
		'            colorValue.y = 1.0-gray_val.x/0.6;',
		'            colorValue.z = gray_val.x/1.8;',
		'          }',
		'          if (uIndexOfImage==2) //only refl',
		'          {',
		'              colorValue.z = gray_val.z;',
		'          }',
		'          sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF);',
		'          sample.rgb = (1.0 - accum.a) * hsv2rgb(colorValue.rgb) * sample.a;',
		'          vec3 tmp = vec3(0.3, 0.59, 0.11);',
		'          float grayscale=dot(sample.rgb, tmp);',
		'          accum += vec4(grayscale,grayscale,grayscale,sample.a);',
		'          if(accum.a>=1.0)',
		'             break;',
		'        }',
		'     }',
		'     //advance the current position',
		'     vpos.xyz += Step;',
		'   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)',
		'         break;',
		' }',
		' gl_FragColor = accum;',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassNearestNeighbour = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uTransferFunction" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uColorVal" : { type: "f", value: -1 },
		"uAbsorptionModeIndex" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"uSteps" : { type: "f", value: -1 },
		"uZFactor" : { type: "f", value: -1 },
		"uAvailable_textures_number" : { type: "i", value: 0 },
		}
	]),
	vertexShader: [
		'varying vec3 worldSpaceCoords;',
		'varying vec4 projectedCoords;',
		' ',
		'void main()',
		'{',
		'    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;',
		'    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'}'].join("\n"),
	fragmentShader: [
		'#ifdef GL_FRAGMENT_PRECISION_HIGH ',
		' // highp is supported ',
		' precision highp int; ',
		' precision highp float; ',
		'#else ',
		' // high is not supported ',
		' precision mediump int; ',
		' precision mediump float; ',
		'#endif ',
		'// Passed from vertex',
		'varying vec3 worldSpaceCoords; ',
		'varying vec4 projectedCoords; ',
		'// Passed from core',
		'uniform sampler2D uBackCoord; ',
		'uniform sampler2D uTransferFunction;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uSlicemapWidth;',
		'// Assuming a bounding box of 512x512x512',
		'// ceil( sqrt(3) * 512 ) = 887',
		'const int MAX_STEPS = 887;',
		'// Application specific parameters',
		'uniform float uNumberOfSlices; ',
		'uniform float uMinGrayVal; ',
		'uniform float uMaxGrayVal; ',
		'uniform float uOpacityVal; ',
		'uniform float uColorVal; ',
		'uniform float uAbsorptionModeIndex;',
		'uniform float uSlicesOverX; ',
		'uniform float uSlicesOverY; ',
		'uniform float uSteps;',
		'uniform float uZFactor;',
		'// uniform int uAvailable_textures_number;',
		'vec4 getVolumeValue(vec3 volpos)',
		'{',
		'    float s1Original, s2Original, s1, s2; ',
		'    float dx1, dy1; ',
		'    // float dx2, dy2; ',
		'    // float value; ',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float delta = 1.0 / sliceSizeX;',
		'    ',
		'    float adapted_x, adapted_y, adapted_z;',
		'    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;',
		'    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;',
		'    adapted_z = 1.0 - ((volpos.z * (1.0 - (2.0*delta))) + delta);',
		'    s1Original = floor(adapted_z*uNumberOfSlices);',
		'    //s1Original = floor(volpos.z*uNumberOfSlices); ',
		'    // s2Original = min(s1Original + 1.0, uNumberOfSlices);',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    // int tex2Index = int(floor(s2Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    // s2 = mod(s2Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;',
		'    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;',
		' ',
		'    float value2 = 0.0;',
		'    vec4 value1;',
		'    // bool value1Set = false, value2Set = false;',
		'    // int numberOfSlicemaps = int( ceil(uNumberOfSlices / (uSlicesOverX * uSlicesOverY)) );',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'    <% } %>',
		'    return value1;',
		'    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)',
		'    // {',
		'    //     if(x == numberOfSlicemaps)',
		'    //     {',
		'    //         break;',
		'    //     }',
		'    //     if(x == tex1Index) { ',
		'    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ',
		'    //         value1Set = true; ',
		'    //     } ',
		'    //     if(x == tex2Index) { ',
		'    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ',
		'    //         value2Set = true; ',
		'    //     } ',
		'    //     if(value1Set && value2Set) { ',
		'    //         break; ',
		'    //     } ',
		'    // } ',
		'    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices)); ',
		'} ',
		'void main(void) {',
		' ',
		'    //Transform the coordinates it from [-1;1] to [0;1]',
		'    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,',
		'                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);',
		'    //The back position is the world space position stored in the texture.',
		'    vec3 backPos = texture2D(uBackCoord, texc).xyz;',
		'                ',
		'    //The front position is the world space position of the second render pass.',
		'    vec3 frontPos = worldSpaceCoords;',
		' ',
		'    //The direction from the front position to back position.',
		'    vec3 dir = backPos - frontPos;',
		'    //vec3 dir = frontPos - backPos;',
		' ',
		'    float rayLength = length(dir);',
		'    //Calculate how long to increment in each step.',
		'    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uZFactor;',
		'    float delta = 1.0 / steps;',
		'    ',
		'    //The increment in each direction for each step.',
		'    vec3 deltaDirection = normalize(dir) * delta;',
		'    float deltaDirectionLength = length(deltaDirection);',
		'    //Start the ray casting from the front position.',
		'    vec3 currentPosition = frontPos;',
		'    //The color accumulator.',
		'    vec4 accumulatedColor = vec4(0.0);',
		'    //The alpha value accumulated so far.',
		'    float accumulatedAlpha = 0.0;',
		'    ',
		'    //How long has the ray travelled so far.',
		'    float accumulatedLength = 0.0;',
		'    ',
		'    //If we have twice as many samples, we only need ~1/2 the alpha per sample.',
		'    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.',
		'    float alphaScaleFactor = 25.6 * delta;',
		'    ',
		'    vec4 colorSample;',
		'    float alphaSample;',
		'    float alphaCorrection = 1.0;',
		'    ',
		'    //Perform the ray marching iterations',
		'    for(int i = 0; i < MAX_STEPS; i++) {',
		'        //Get the voxel intensity value from the 3D texture.',
		'        //colorSample = sampleAs3DTexture( currentPosition );',
		'        ',
		'        colorSample = getVolumeValue( currentPosition );',
		'        ',
		'        //Allow the alpha correction customization.',
		'        alphaSample = colorSample.a * alphaCorrection;',
		'        ',
		'        //Applying this effect to both the color and alpha accumulation results in more realistic transparency.',
		'        alphaSample *= (1.0 - accumulatedAlpha);',
		'        ',
		'        //Scaling alpha by the number of steps makes the final color invariant to the step size.',
		'        alphaSample *= alphaScaleFactor;',
		'        ',
		'        //Perform the composition.',
		'        accumulatedColor += colorSample * alphaSample;',
		'        ',
		'        //Store the alpha accumulated so far.',
		'        accumulatedAlpha += alphaSample;',
		'        ',
		'        //Advance the ray.',
		'        currentPosition += deltaDirection;',
		'					',
		'        accumulatedLength += deltaDirectionLength;',
		'        ',
		'        //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.',
		'        if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )',
		'            break;',
		'    }',
		'    gl_FragColor = accumulatedColor; ',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassNearestNeighbourB = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uTransferFunction" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uColorVal" : { type: "f", value: -1 },
		"uAbsorptionModeIndex" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"uSteps" : { type: "f", value: -1 },
		"uRatio" : { type: "f", value: -1 },
		"uAvailable_textures_number" : { type: "i", value: 0 },
		}
	]),
	vertexShader: [
		'varying vec3 worldSpaceCoords;',
		'varying vec4 projectedCoords;',
		' ',
		'void main()',
		'{',
		'    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;',
		'    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'}'].join("\n"),
	fragmentShader: [
		'#ifdef GL_FRAGMENT_PRECISION_HIGH ',
		' // highp is supported ',
		' precision highp int; ',
		' precision highp float; ',
		'#else ',
		' // high is not supported ',
		' precision mediump int; ',
		' precision mediump float; ',
		'#endif ',
		'// Passed from vertex',
		'varying vec3 worldSpaceCoords; ',
		'varying vec4 projectedCoords; ',
		'// Passed from core',
		'uniform sampler2D uBackCoord; ',
		'uniform sampler2D uTransferFunction;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uSlicemapWidth;',
		'// Assuming a bounding box of 512x512x512',
		'// ceil( sqrt(3) * 512 ) = 887',
		'const int MAX_STEPS = 887;',
		'// Application specific parameters',
		'uniform float uNumberOfSlices; ',
		'uniform float uMinGrayVal; ',
		'uniform float uMaxGrayVal;',
		'uniform float uOpacityVal; ',
		'uniform float uColorVal; ',
		'uniform float uAbsorptionModeIndex;',
		'uniform float uSlicesOverX; ',
		'uniform float uSlicesOverY; ',
		'uniform float uSteps;',
		'uniform float uRatio;',
		'// uniform int uAvailable_textures_number;',
		'vec4 getVolumeValue(vec3 volpos)',
		'{',
		'    //if (volpos.z < 0.5)',
		'    //    return vec4(0.0);',
		'    float s1Original, s2Original, s1, s2; ',
		'    float dx1, dy1; ',
		'    // float dx2, dy2; ',
		'    // float value; ',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float delta = 1.0 / sliceSizeX;',
		'    ',
		'    float adapted_x, adapted_y, adapted_z;',
		'    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;',
		'    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;',
		'    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);',
		'    s1Original = floor(adapted_z*uNumberOfSlices);',
		'    //s1Original = floor(volpos.z*uNumberOfSlices); ',
		'    //s2Original = min(s1Original + 1.0, uNumberOfSlices);',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    //int tex2Index = int(floor(s2Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    //s2 = mod(s2Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;',
		'    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;',
		' ',
		'    float value2 = 0.0;',
		'    vec4 value1;',
		'    // bool value1Set = false, value2Set = false;',
		'    // int numberOfSlicemaps = int( ceil(uNumberOfSlices / (uSlicesOverX * uSlicesOverY)) );',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'    <% } %>',
		'    return value1;',
		'    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)',
		'    // {',
		'    //     if(x == numberOfSlicemaps)',
		'    //     {',
		'    //         break;',
		'    //     }',
		'    //     if(x == tex1Index) { ',
		'    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ',
		'    //         value1Set = true; ',
		'    //     } ',
		'    //     if(x == tex2Index) { ',
		'    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ',
		'    //         value2Set = true; ',
		'    //     } ',
		'    //     if(value1Set && value2Set) { ',
		'    //         break; ',
		'    //     } ',
		'    // } ',
		'    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices));',
		'}',
		'void main(void) {',
		' ',
		'    //Transform the coordinates it from [-1;1] to [0;1]',
		'    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,',
		'                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);',
		'    //The back position is the world space position stored in the texture.',
		'    vec3 backPos = texture2D(uBackCoord, texc).xyz;',
		'                ',
		'    //The front position is the world space position of the second render pass.',
		'    vec3 frontPos = worldSpaceCoords;',
		' ',
		'    //The direction from the front position to back position.',
		'    vec3 dir = backPos - frontPos;',
		'    float rayLength = length(dir);',
		'    //Calculate how long to increment in each step.',
		'    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;',
		'    //float steps = 256.0;',
		'    float delta = 1.0 / steps;',
		'    ',
		'    //The increment in each direction for each step.',
		'    vec3 deltaDirection = normalize(dir) * delta;',
		'    ',
		'    vec3 Step = dir / steps;',
		'    ',
		'    float deltaDirectionLength = length(deltaDirection);',
		'    //vec4 vpos = frontColor;  // currentPosition',
		'    //vec3 Step = dir/uStepsF; // steps',
		'    //Start the ray casting from the front position.',
		'    vec3 currentPosition = frontPos;',
		'    //The color accumulator.',
		'    vec4 accumulatedColor = vec4(0.0);',
		'    //The alpha value accumulated so far.',
		'    float accumulatedAlpha = 0.0;',
		'    ',
		'    //How long has the ray travelled so far.',
		'    float accumulatedLength = 0.0;',
		'    ',
		'    //If we have twice as many samples, we only need ~1/2 the alpha per sample.',
		'    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.',
		'    float alphaScaleFactor = 28.8 * delta;',
		'    ',
		'    vec4 colorSample = vec4(0.0);',
		'    vec4 sample = vec4(0.0); ',
		'    vec4 grayValue;',
		'    float alphaSample;',
		'    float alphaCorrection = 1.0;',
		'    ',
		'    //Perform the ray marching iterations',
		'    for(int i = 0; i < MAX_STEPS; i++) {       ',
		'        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)      ',
		'            break;',
		'        if(accumulatedColor.a>=1.0) ',
		'            break;',
		'        grayValue = getVolumeValue(currentPosition); ',
		'        if(grayValue.z < 0.05 || ',
		'           grayValue.z < 0.0 ||',
		'           grayValue.z > 1.0)  ',
		'            accumulatedColor = vec4(0.0);     ',
		'        else { ',
		'            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;',
		'            colorSample.x = grayValue.z;',
		'            //colorSample.w = alphaScaleFactor;',
		'            colorSample.w = 0.1;',
		'              ',
		'            //sample.a = colorSample.a * 40.0 * (1.0 / steps);',
		'            sample.a = colorSample.a;',
		'            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xxx * sample.a; ',
		'             ',
		'            accumulatedColor += sample; ',
		'        }    ',
		'   ',
		'        //Advance the ray.',
		'        //currentPosition.xyz += deltaDirection;',
		'        currentPosition.xyz += Step;',
		'   ',
		'         ',
		'    } ',
		'    gl_FragColor = accumulatedColor; ',
		'    /*',
		'    for(int i = 0; i < MAX_STEPS; i++) {',
		'        ',
		'        grayValue = getVolumeValue( currentPosition );',
		'        ',
		'        if(grayValue.r < uMinGrayVal || grayValue.r > uMaxGrayVal || grayValue.b < 0.05) { ',
		'            accumulatedColor = vec4(0.0); ',
		'        } else {',
		'            colorSample.rgb = vec3(1.0,0.0,0.0);',
		'            colorSample.a = 1.0;',
		'            ',
		'            alphaSample = colorSample.a * alphaCorrection;',
		'        ',
		'            //Applying this effect to both the color and alpha accumulation results in more realistic transparency.',
		'            alphaSample *= (1.0 - accumulatedAlpha);',
		'        ',
		'            //Scaling alpha by the number of steps makes the final color invariant to the step size.',
		'            alphaSample *= alphaScaleFactor;',
		'        ',
		'            //Perform the composition.',
		'            accumulatedColor += colorSample * alphaSample * 100.0;',
		'        ',
		'            //Store the alpha accumulated so far.',
		'            accumulatedAlpha += alphaSample;',
		'            ',
		'            accumulatedColor = colorSample;',
		'        }',
		'        //Advance the ray.',
		'        currentPosition += deltaDirection;',
		'					',
		'        accumulatedLength += deltaDirectionLength;',
		'        ',
		'        //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.',
		'        if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )',
		'            break;',
		'    }',
		'    gl_FragColor = accumulatedColor;',
		'    */',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassNearestNeighbourG = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uTransferFunction" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uColorVal" : { type: "f", value: -1 },
		"uAbsorptionModeIndex" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"uSteps" : { type: "f", value: -1 },
		"uRatio" : { type: "f", value: -1 },
		"uAvailable_textures_number" : { type: "i", value: 0 },
		}
	]),
	vertexShader: [
		'varying vec3 worldSpaceCoords;',
		'varying vec4 projectedCoords;',
		' ',
		'void main()',
		'{',
		'    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;',
		'    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'}'].join("\n"),
	fragmentShader: [
		'#ifdef GL_FRAGMENT_PRECISION_HIGH ',
		' // highp is supported ',
		' precision highp int; ',
		' precision highp float; ',
		'#else ',
		' // high is not supported ',
		' precision mediump int; ',
		' precision mediump float; ',
		'#endif ',
		'// Passed from vertex',
		'varying vec3 worldSpaceCoords; ',
		'varying vec4 projectedCoords; ',
		'// Passed from core',
		'uniform sampler2D uBackCoord; ',
		'uniform sampler2D uTransferFunction;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uSlicemapWidth;',
		'// Assuming a bounding box of 512x512x512',
		'// ceil( sqrt(3) * 512 ) = 887',
		'const int MAX_STEPS = 887;',
		'// Application specific parameters',
		'uniform float uNumberOfSlices; ',
		'uniform float uMinGrayVal; ',
		'uniform float uMaxGrayVal;',
		'uniform float uOpacityVal; ',
		'uniform float uColorVal; ',
		'uniform float uAbsorptionModeIndex;',
		'uniform float uSlicesOverX; ',
		'uniform float uSlicesOverY; ',
		'uniform float uSteps;',
		'uniform float uRatio;',
		'// uniform int uAvailable_textures_number;',
		'vec4 getVolumeValue(vec3 volpos)',
		'{',
		'    //if (volpos.z < 0.5)',
		'    //    return vec4(0.0);',
		'    float s1Original, s2Original, s1, s2; ',
		'    float dx1, dy1; ',
		'    // float dx2, dy2; ',
		'    // float value; ',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float delta = 1.0 / sliceSizeX;',
		'    ',
		'    float adapted_x, adapted_y, adapted_z;',
		'    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;',
		'    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;',
		'    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);',
		'    s1Original = floor(adapted_z*uNumberOfSlices);',
		'    //s1Original = floor(volpos.z*uNumberOfSlices); ',
		'    //s2Original = min(s1Original + 1.0, uNumberOfSlices);',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    //int tex2Index = int(floor(s2Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    //s2 = mod(s2Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;',
		'    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;',
		' ',
		'    float value2 = 0.0;',
		'    vec4 value1;',
		'    // bool value1Set = false, value2Set = false;',
		'    // int numberOfSlicemaps = int( ceil(uNumberOfSlices / (uSlicesOverX * uSlicesOverY)) );',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'    <% } %>',
		'    return value1;',
		'    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)',
		'    // {',
		'    //     if(x == numberOfSlicemaps)',
		'    //     {',
		'    //         break;',
		'    //     }',
		'    //     if(x == tex1Index) { ',
		'    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ',
		'    //         value1Set = true; ',
		'    //     } ',
		'    //     if(x == tex2Index) { ',
		'    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ',
		'    //         value2Set = true; ',
		'    //     } ',
		'    //     if(value1Set && value2Set) { ',
		'    //         break; ',
		'    //     } ',
		'    // } ',
		'    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices));',
		'}',
		'void main(void) {',
		' ',
		'    //Transform the coordinates it from [-1;1] to [0;1]',
		'    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,',
		'                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);',
		'    //The back position is the world space position stored in the texture.',
		'    vec3 backPos = texture2D(uBackCoord, texc).xyz;',
		'                ',
		'    //The front position is the world space position of the second render pass.',
		'    vec3 frontPos = worldSpaceCoords;',
		' ',
		'    //The direction from the front position to back position.',
		'    vec3 dir = backPos - frontPos;',
		'    float rayLength = length(dir);',
		'    //Calculate how long to increment in each step.',
		'    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;',
		'    //float steps = 256.0;',
		'    float delta = 1.0 / steps;',
		'    ',
		'    //The increment in each direction for each step.',
		'    vec3 deltaDirection = normalize(dir) * delta;',
		'    ',
		'    vec3 Step = dir / steps;',
		'    ',
		'    float deltaDirectionLength = length(deltaDirection);',
		'    //vec4 vpos = frontColor;  // currentPosition',
		'    //vec3 Step = dir/uStepsF; // steps',
		'    //Start the ray casting from the front position.',
		'    vec3 currentPosition = frontPos;',
		'    //The color accumulator.',
		'    vec4 accumulatedColor = vec4(0.0);',
		'    //The alpha value accumulated so far.',
		'    float accumulatedAlpha = 0.0;',
		'    ',
		'    //How long has the ray travelled so far.',
		'    float accumulatedLength = 0.0;',
		'    ',
		'    //If we have twice as many samples, we only need ~1/2 the alpha per sample.',
		'    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.',
		'    float alphaScaleFactor = 28.8 * delta;',
		'    ',
		'    vec4 colorSample = vec4(0.0);',
		'    vec4 sample = vec4(0.0); ',
		'    vec4 grayValue;',
		'    float alphaSample;',
		'    float alphaCorrection = 1.0;',
		'    ',
		'    //Perform the ray marching iterations',
		'    for(int i = 0; i < MAX_STEPS; i++) {       ',
		'        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)      ',
		'            break;',
		'        if(accumulatedColor.a>=1.0) ',
		'            break;',
		'        grayValue = getVolumeValue(currentPosition); ',
		'        if(grayValue.z < 0.05 || ',
		'           grayValue.y < 0.0 ||',
		'           grayValue.y > 1.0)  ',
		'            accumulatedColor = vec4(0.0);     ',
		'        else { ',
		'            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;',
		'            colorSample.x = grayValue.y;',
		'            //colorSample.w = alphaScaleFactor;',
		'            colorSample.w = 0.1;',
		'              ',
		'            //sample.a = colorSample.a * 40.0 * (1.0 / steps);',
		'            sample.a = colorSample.a;',
		'            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xxx * sample.a; ',
		'             ',
		'            accumulatedColor += sample; ',
		'        }    ',
		'   ',
		'        //Advance the ray.',
		'        //currentPosition.xyz += deltaDirection;',
		'        currentPosition.xyz += Step;',
		'   ',
		'         ',
		'    } ',
		'    gl_FragColor = accumulatedColor; ',
		'    /*',
		'    for(int i = 0; i < MAX_STEPS; i++) {',
		'        ',
		'        grayValue = getVolumeValue( currentPosition );',
		'        ',
		'        if(grayValue.r < uMinGrayVal || grayValue.r > uMaxGrayVal || grayValue.b < 0.05) { ',
		'            accumulatedColor = vec4(0.0); ',
		'        } else {',
		'            colorSample.rgb = vec3(1.0,0.0,0.0);',
		'            colorSample.a = 1.0;',
		'            ',
		'            alphaSample = colorSample.a * alphaCorrection;',
		'        ',
		'            //Applying this effect to both the color and alpha accumulation results in more realistic transparency.',
		'            alphaSample *= (1.0 - accumulatedAlpha);',
		'        ',
		'            //Scaling alpha by the number of steps makes the final color invariant to the step size.',
		'            alphaSample *= alphaScaleFactor;',
		'        ',
		'            //Perform the composition.',
		'            accumulatedColor += colorSample * alphaSample * 100.0;',
		'        ',
		'            //Store the alpha accumulated so far.',
		'            accumulatedAlpha += alphaSample;',
		'            ',
		'            accumulatedColor = colorSample;',
		'        }',
		'        //Advance the ray.',
		'        currentPosition += deltaDirection;',
		'					',
		'        accumulatedLength += deltaDirectionLength;',
		'        ',
		'        //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.',
		'        if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )',
		'            break;',
		'    }',
		'    gl_FragColor = accumulatedColor;',
		'    */',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassNearestNeighbourHSVFusion = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uTransferFunction" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uColorVal" : { type: "f", value: -1 },
		"uAbsorptionModeIndex" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"uSteps" : { type: "f", value: -1 },
		"uRatio" : { type: "f", value: -1 },
		"uIndexOfImage" : { type: "f", value: -1 },
		"uAvailable_textures_number" : { type: "i", value: 0 },
		}
	]),
	vertexShader: [
		'varying vec3 worldSpaceCoords;',
		'varying vec4 projectedCoords;',
		' ',
		'void main()',
		'{',
		'    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;',
		'    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'}'].join("\n"),
	fragmentShader: [
		'#ifdef GL_FRAGMENT_PRECISION_HIGH',
		' // highp is supported',
		' precision highp int;',
		' precision highp float;',
		'#else',
		' // high is not supported',
		' precision mediump int;',
		' precision mediump float;',
		'#endif',
		'// Passed from vertex',
		'varying vec3 worldSpaceCoords;',
		'varying vec4 projectedCoords;',
		'// Passed from core',
		'uniform sampler2D uBackCoord;',
		'uniform sampler2D uTransferFunction;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uSlicemapWidth;',
		'// Assuming a bounding box of 512x512x512',
		'// ceil( sqrt(3) * 512 ) = 887',
		'const int MAX_STEPS = 887;',
		'// Application specific parameters',
		'uniform float uNumberOfSlices;',
		'uniform float uMinGrayVal;',
		'uniform float uMaxGrayVal;',
		'uniform float uOpacityVal;',
		'uniform float uColorVal;',
		'uniform float uAbsorptionModeIndex;',
		'uniform float uSlicesOverX;',
		'uniform float uSlicesOverY;',
		'uniform float uSteps;',
		'uniform float uRatio;',
		'uniform float uIndexOfImage;',
		'// uniform int uAvailable_textures_number;',
		'vec4 getVolumeValue(vec3 volpos)',
		'{',
		'    //if (volpos.z < 0.5)',
		'    //    return vec4(0.0);',
		'    float s1Original, s2Original, s1, s2;',
		'    float dx1, dy1;',
		'    // float dx2, dy2;',
		'    // float value;',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float delta = 1.0 / sliceSizeX;',
		'    float adapted_x, adapted_y, adapted_z;',
		'    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;',
		'    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;',
		'    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) );',
		'    // s1Original = floor(adapted_z*uNumberOfSlices);',
		'    if(adapted_z>0.0) {',
		'        s1Original = floor(adapted_z*uNumberOfSlices);',
		'    } else {',
		'        s1Original = (1.0 - (0.5 / uNumberOfSlices)) * uNumberOfSlices;',
		'    }',
		'    //s1Original = floor(volpos.z*uNumberOfSlices);',
		'    //s2Original = min(s1Original + 1.0, uNumberOfSlices);',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    //int tex2Index = int(floor(s2Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    //s2 = mod(s2Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;',
		'    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;',
		'    float value2 = 0.0;',
		'    vec4 value1;',
		'    // bool value1Set = false, value2Set = false;',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'    <% } %>',
		'    return value1;',
		'}',
		'// x - R, y - G, z - B',
		'// x - H, y - S, z - V',
		'vec3 hsv2rgb(vec3 hsv)',
		'{',
		'    float     hue, p, q, t, ff;',
		'    int        i;',
		'    //"opacity_factor": 40,',
		'    //"color_factor": 0.4,',
		'    //"x_min": 0,',
		'    //"x_max": 1,',
		'    //"l": 5,',
		'    //"s" : 1,',
		'    //"hMin" : -0.5,',
		'    //"hMax" : 1,',
		'    //"minRefl" : 0,',
		'    //"minSos" : 0,',
		'    //"minAtten" : 0,',
		'    //"maxRefl" : 100,',
		'    //"maxSos" : 100,',
		'    //"maxAtten" : 100,',
		'    float darkness = 0.4;',
		'    float l = 5.0;',
		'    float s = 1.0;',
		'    float hMin = -0.5;',
		'    float hMax = 1.0;',
		'    hsv.z = (darkness - hsv.z) * l;',
		'    hsv.x = (hsv.x - hMin)/(hMax - hMin) * 360.0;',
		'    hsv.y *= s * 1.5;',
		'    hue=hsv.x >= 360.0?hsv.x-360.0:hsv.x;',
		'    hue /= 60.0;',
		'    i = int(hue);',
		'    ff = hue - float(i);',
		'    p = hsv.z * (1.0 - hsv.y);',
		'    q = hsv.z * (1.0 - (hsv.y * ff));',
		'    t = hsv.z * (1.0 - (hsv.y * (1.0 - ff)));',
		'    if(i==0)',
		'        return vec3(hsv.z,t,p);',
		'    else if(i==1)',
		'      return vec3(q,hsv.z,p);',
		'    else if(i==2)',
		'        return vec3(p,hsv.z,t);',
		'    else if(i==3)',
		'        return vec3(p,q,hsv.z);',
		'    else if(i==4)',
		'        return vec3(t,p,hsv.z);',
		'    else',
		'        return vec3(hsv.z,p,q);',
		'}',
		'void main(void) {',
		'    //Transform the coordinates it from [-1;1] to [0;1]',
		'    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,',
		'                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);',
		'    //The back position is the world space position stored in the texture.',
		'    vec3 backPos = texture2D(uBackCoord, texc).xyz;',
		'    //The front position is the world space position of the second render pass.',
		'    vec3 frontPos = worldSpaceCoords;',
		'    //The direction from the front position to back position.',
		'    vec3 dir = backPos - frontPos;',
		'    float rayLength = length(dir);',
		'    //Calculate how long to increment in each step.',
		'    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;',
		'    //float steps = 256.0;',
		'    float delta = 1.0 / steps;',
		'    //The increment in each direction for each step.',
		'    vec3 deltaDirection = normalize(dir) * delta;',
		'    vec3 Step = dir / steps;',
		'    float deltaDirectionLength = length(deltaDirection);',
		'    //vec4 vpos = frontColor;  // currentPosition',
		'    //vec3 Step = dir/uStepsF; // steps',
		'    //Start the ray casting from the front position.',
		'    vec3 currentPosition = frontPos;',
		'    //The color accumulator.',
		'    vec4 accumulatedColor = vec4(0.0);',
		'    //The alpha value accumulated so far.',
		'    float accumulatedAlpha = 0.0;',
		'    //How long has the ray travelled so far.',
		'    float accumulatedLength = 0.0;',
		'    //If we have twice as many samples, we only need ~1/2 the alpha per sample.',
		'    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.',
		'    float alphaScaleFactor = 28.8 * delta;',
		'    vec4 colorSample = vec4(0.0);',
		'    vec4 sample = vec4(0.0);',
		'    vec4 grayValue;',
		'    float alphaSample;',
		'    float alphaCorrection = 1.0;',
		'    //Perform the ray marching iterations',
		'    for(int i = 0; i < MAX_STEPS; i++) {',
		'        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)',
		'            break;',
		'        if(accumulatedColor.a>=1.0)',
		'            break;',
		'        grayValue = getVolumeValue(currentPosition);',
		'        if(grayValue.z < 0.05 ||',
		'           grayValue.x < 0.0 ||',
		'           grayValue.x > 1.0)',
		'            accumulatedColor = vec4(0.0);',
		'        else {',
		'          if (uIndexOfImage==0.0)',
		'          {',
		'            // colorSample.xyz = grayValue.xyz;',
		'            colorSample.x = grayValue.x;',
		'            colorSample.y = 1.0-grayValue.y/0.6;',
		'            colorSample.z = grayValue.z;',
		'            colorSample.w = 0.04;',
		'            // colorSample.w = 0.04;',
		'            // colorSample.x = grayValue.x;',
		'            // colorSample.y = 1.0-grayValue.x/0.6;',
		'            // colorSample.z = grayValue.x/1.8;',
		'            // colorSample.w = 0.04;',
		'            // colorSample.x = grayValue.y;',
		'            // colorSample.y = 1.0-grayValue.y/0.7;',
		'            // colorSample.z = grayValue.y/1.8;',
		'            // colorSample.w = 0.03;',
		'            // colorSample.x = grayValue.z;',
		'            // colorSample.y = grayValue.z;',
		'            // colorSample.z = grayValue.z;',
		'          }',
		'          if (uIndexOfImage==1.0)',
		'          {',
		'            colorSample.w = 0.04;',
		'            colorSample.x = grayValue.x;',
		'            colorSample.y = 1.0-grayValue.x/0.6;',
		'            colorSample.z = grayValue.x/1.8;',
		'          }',
		'          if (uIndexOfImage==2.0)',
		'          {',
		'            colorSample.w = 0.04;',
		'            colorSample.x = grayValue.y;',
		'            colorSample.y = 1.0-grayValue.y/0.7;',
		'            colorSample.z = grayValue.y/1.8;',
		'          }',
		'          if (uIndexOfImage==3.0)',
		'          {',
		'            colorSample.w = 0.03;',
		'            colorSample.x = grayValue.z;',
		'            colorSample.y = grayValue.z;',
		'            colorSample.z = grayValue.z;',
		'          }',
		'            //sample.a = colorSample.a * 40.0 * (1.0 / steps);',
		'            sample.a = colorSample.a;',
		'            sample.rgb = (1.0 - accumulatedColor.a) * hsv2rgb(colorSample.xyz) * sample.a;',
		'          if(uIndexOfImage==0.0) // multimodality',
		'          {',
		'            accumulatedColor += sample;',
		'            // accumulatedColor += vec4(currentPosition.xyz,sample.a);',
		'          }',
		'          else // single modality',
		'          {',
		'            vec3 tmp = vec3(0.3, 0.59, 0.11);',
		'            float grayscale=dot(sample.rgb, tmp);',
		'            accumulatedColor += vec4(grayscale,grayscale,grayscale,sample.a);',
		'          }',
		'        }',
		'        //Advance the ray.',
		'        //currentPosition.xyz += deltaDirection;',
		'        currentPosition.xyz += Step;',
		'    }',
		'    gl_FragColor = accumulatedColor;',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassNearestNeighbourR = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uTransferFunction" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uColorVal" : { type: "f", value: -1 },
		"uAbsorptionModeIndex" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"uSteps" : { type: "f", value: -1 },
		"uRatio" : { type: "f", value: -1 },
		"uAvailable_textures_number" : { type: "i", value: 0 },
		}
	]),
	vertexShader: [
		'varying vec3 worldSpaceCoords;',
		'varying vec4 projectedCoords;',
		' ',
		'void main()',
		'{',
		'    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;',
		'    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'}'].join("\n"),
	fragmentShader: [
		'#ifdef GL_FRAGMENT_PRECISION_HIGH ',
		' // highp is supported ',
		' precision highp int; ',
		' precision highp float; ',
		'#else ',
		' // high is not supported ',
		' precision mediump int; ',
		' precision mediump float; ',
		'#endif ',
		'// Passed from vertex',
		'varying vec3 worldSpaceCoords; ',
		'varying vec4 projectedCoords; ',
		'// Passed from core',
		'uniform sampler2D uBackCoord; ',
		'uniform sampler2D uTransferFunction;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uSlicemapWidth;',
		'// Assuming a bounding box of 512x512x512',
		'// ceil( sqrt(3) * 512 ) = 887',
		'const int MAX_STEPS = 887;',
		'// Application specific parameters',
		'uniform float uNumberOfSlices; ',
		'uniform float uMinGrayVal; ',
		'uniform float uMaxGrayVal;',
		'uniform float uOpacityVal; ',
		'uniform float uColorVal; ',
		'uniform float uAbsorptionModeIndex;',
		'uniform float uSlicesOverX; ',
		'uniform float uSlicesOverY; ',
		'uniform float uSteps;',
		'uniform float uRatio;',
		'// uniform int uAvailable_textures_number;',
		'vec4 getVolumeValue(vec3 volpos)',
		'{',
		'    //if (volpos.z < 0.5)',
		'    //    return vec4(0.0);',
		'    float s1Original, s2Original, s1, s2; ',
		'    float dx1, dy1; ',
		'    // float dx2, dy2; ',
		'    // float value; ',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float delta = 1.0 / sliceSizeX;',
		'    ',
		'    float adapted_x, adapted_y, adapted_z;',
		'    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;',
		'    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;',
		'    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);',
		'    s1Original = floor(adapted_z*uNumberOfSlices);',
		'    //s1Original = floor(volpos.z*uNumberOfSlices); ',
		'    //s2Original = min(s1Original + 1.0, uNumberOfSlices);',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    //int tex2Index = int(floor(s2Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    //s2 = mod(s2Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;',
		'    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;',
		' ',
		'    float value2 = 0.0;',
		'    vec4 value1;',
		'    // bool value1Set = false, value2Set = false;',
		'    // int numberOfSlicemaps = int( ceil(uNumberOfSlices / (uSlicesOverX * uSlicesOverY)) );',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'    <% } %>',
		'    return value1;',
		'    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)',
		'    // {',
		'    //     if(x == numberOfSlicemaps)',
		'    //     {',
		'    //         break;',
		'    //     }',
		'    //     if(x == tex1Index) { ',
		'    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ',
		'    //         value1Set = true; ',
		'    //     } ',
		'    //     if(x == tex2Index) { ',
		'    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ',
		'    //         value2Set = true; ',
		'    //     } ',
		'    //     if(value1Set && value2Set) { ',
		'    //         break; ',
		'    //     } ',
		'    // } ',
		'    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices));',
		'}',
		'void main(void) {',
		' ',
		'    //Transform the coordinates it from [-1;1] to [0;1]',
		'    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,',
		'                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);',
		'    //The back position is the world space position stored in the texture.',
		'    vec3 backPos = texture2D(uBackCoord, texc).xyz;',
		'                ',
		'    //The front position is the world space position of the second render pass.',
		'    vec3 frontPos = worldSpaceCoords;',
		' ',
		'    //The direction from the front position to back position.',
		'    vec3 dir = backPos - frontPos;',
		'    float rayLength = length(dir);',
		'    //Calculate how long to increment in each step.',
		'    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;',
		'    //float steps = 256.0;',
		'    float delta = 1.0 / steps;',
		'    ',
		'    //The increment in each direction for each step.',
		'    vec3 deltaDirection = normalize(dir) * delta;',
		'    ',
		'    vec3 Step = dir / steps;',
		'    ',
		'    float deltaDirectionLength = length(deltaDirection);',
		'    //vec4 vpos = frontColor;  // currentPosition',
		'    //vec3 Step = dir/uStepsF; // steps',
		'    //Start the ray casting from the front position.',
		'    vec3 currentPosition = frontPos;',
		'    //The color accumulator.',
		'    vec4 accumulatedColor = vec4(0.0);',
		'    //The alpha value accumulated so far.',
		'    float accumulatedAlpha = 0.0;',
		'    ',
		'    //How long has the ray travelled so far.',
		'    float accumulatedLength = 0.0;',
		'    ',
		'    //If we have twice as many samples, we only need ~1/2 the alpha per sample.',
		'    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.',
		'    float alphaScaleFactor = 28.8 * delta;',
		'    ',
		'    vec4 colorSample = vec4(0.0);',
		'    vec4 sample = vec4(0.0); ',
		'    vec4 grayValue;',
		'    float alphaSample;',
		'    float alphaCorrection = 1.0;',
		'    ',
		'    //Perform the ray marching iterations',
		'    for(int i = 0; i < MAX_STEPS; i++) {       ',
		'        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)      ',
		'            break;',
		'        if(accumulatedColor.a>=1.0) ',
		'            break;',
		'        grayValue = getVolumeValue(currentPosition); ',
		'        if(grayValue.z < 0.05 || ',
		'           grayValue.x < 0.0 ||',
		'           grayValue.x > 1.0)  ',
		'            accumulatedColor = vec4(0.0);     ',
		'        else { ',
		'            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;',
		'            colorSample.x = grayValue.x;',
		'            //colorSample.w = alphaScaleFactor;',
		'            colorSample.w = 0.1;',
		'              ',
		'            //sample.a = colorSample.a * 40.0 * (1.0 / steps);',
		'            sample.a = colorSample.a;',
		'            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xxx * sample.a; ',
		'             ',
		'            accumulatedColor += sample; ',
		'        }    ',
		'   ',
		'        //Advance the ray.',
		'        //currentPosition.xyz += deltaDirection;',
		'        currentPosition.xyz += Step;',
		'   ',
		'         ',
		'    } ',
		'    gl_FragColor = accumulatedColor; ',
		'    /*',
		'    for(int i = 0; i < MAX_STEPS; i++) {',
		'        ',
		'        grayValue = getVolumeValue( currentPosition );',
		'        ',
		'        if(grayValue.r < uMinGrayVal || grayValue.r > uMaxGrayVal || grayValue.b < 0.05) { ',
		'            accumulatedColor = vec4(0.0); ',
		'        } else {',
		'            colorSample.rgb = vec3(1.0,0.0,0.0);',
		'            colorSample.a = 1.0;',
		'            ',
		'            alphaSample = colorSample.a * alphaCorrection;',
		'        ',
		'            //Applying this effect to both the color and alpha accumulation results in more realistic transparency.',
		'            alphaSample *= (1.0 - accumulatedAlpha);',
		'        ',
		'            //Scaling alpha by the number of steps makes the final color invariant to the step size.',
		'            alphaSample *= alphaScaleFactor;',
		'        ',
		'            //Perform the composition.',
		'            accumulatedColor += colorSample * alphaSample * 100.0;',
		'        ',
		'            //Store the alpha accumulated so far.',
		'            accumulatedAlpha += alphaSample;',
		'            ',
		'            accumulatedColor = colorSample;',
		'        }',
		'        //Advance the ray.',
		'        currentPosition += deltaDirection;',
		'					',
		'        accumulatedLength += deltaDirectionLength;',
		'        ',
		'        //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.',
		'        if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )',
		'            break;',
		'    }',
		'    gl_FragColor = accumulatedColor;',
		'    */',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassNearestNeighbourRGB = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uTransferFunction" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uColorVal" : { type: "f", value: -1 },
		"uAbsorptionModeIndex" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"uSteps" : { type: "f", value: -1 },
		"uRatio" : { type: "f", value: -1 },
		"uAvailable_textures_number" : { type: "i", value: 0 },
		}
	]),
	vertexShader: [
		'varying vec3 worldSpaceCoords;',
		'varying vec4 projectedCoords;',
		' ',
		'void main()',
		'{',
		'    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;',
		'    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'}'].join("\n"),
	fragmentShader: [
		'#ifdef GL_FRAGMENT_PRECISION_HIGH ',
		' // highp is supported ',
		' precision highp int; ',
		' precision highp float; ',
		'#else ',
		' // high is not supported ',
		' precision mediump int; ',
		' precision mediump float; ',
		'#endif ',
		'// Passed from vertex',
		'varying vec3 worldSpaceCoords; ',
		'varying vec4 projectedCoords; ',
		'// Passed from core',
		'uniform sampler2D uBackCoord; ',
		'uniform sampler2D uTransferFunction;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uSlicemapWidth;',
		'// Assuming a bounding box of 512x512x512',
		'// ceil( sqrt(3) * 512 ) = 887',
		'const int MAX_STEPS = 887;',
		'// Application specific parameters',
		'uniform float uNumberOfSlices; ',
		'uniform float uMinGrayVal; ',
		'uniform float uMaxGrayVal;',
		'uniform float uOpacityVal; ',
		'uniform float uColorVal; ',
		'uniform float uAbsorptionModeIndex;',
		'uniform float uSlicesOverX; ',
		'uniform float uSlicesOverY; ',
		'uniform float uSteps;',
		'uniform float uRatio;',
		'// uniform int uAvailable_textures_number;',
		'vec4 getVolumeValue(vec3 volpos)',
		'{',
		'    //if (volpos.z < 0.5)',
		'    //    return vec4(0.0);',
		'    float s1Original, s2Original, s1, s2; ',
		'    float dx1, dy1; ',
		'    // float dx2, dy2; ',
		'    // float value; ',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float delta = 1.0 / sliceSizeX;',
		'    ',
		'    float adapted_x, adapted_y, adapted_z;',
		'    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;',
		'    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;',
		'    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);',
		'    s1Original = floor(adapted_z*uNumberOfSlices);',
		'    //s1Original = floor(volpos.z*uNumberOfSlices); ',
		'    //s2Original = min(s1Original + 1.0, uNumberOfSlices);',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    //int tex2Index = int(floor(s2Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    //s2 = mod(s2Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;',
		'    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;',
		' ',
		'    float value2 = 0.0;',
		'    vec4 value1;',
		'    // bool value1Set = false, value2Set = false;',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'    <% } %>',
		'    return value1;',
		'    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)',
		'    // {',
		'    //     if(x == numberOfSlicemaps)',
		'    //     {',
		'    //         break;',
		'    //     }',
		'    //     if(x == tex1Index) { ',
		'    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ',
		'    //         value1Set = true; ',
		'    //     } ',
		'    //     if(x == tex2Index) { ',
		'    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ',
		'    //         value2Set = true; ',
		'    //     } ',
		'    //     if(value1Set && value2Set) { ',
		'    //         break; ',
		'    //     } ',
		'    // } ',
		'    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices));',
		'}',
		'void main(void) {',
		' ',
		'    //Transform the coordinates it from [-1;1] to [0;1]',
		'    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,',
		'                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);',
		'    //The back position is the world space position stored in the texture.',
		'    vec3 backPos = texture2D(uBackCoord, texc).xyz;',
		'                ',
		'    //The front position is the world space position of the second render pass.',
		'    vec3 frontPos = worldSpaceCoords;',
		' ',
		'    //The direction from the front position to back position.',
		'    vec3 dir = backPos - frontPos;',
		'    float rayLength = length(dir);',
		'    //Calculate how long to increment in each step.',
		'    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;',
		'    //float steps = 256.0;',
		'    float delta = 1.0 / steps;',
		'    ',
		'    //The increment in each direction for each step.',
		'    vec3 deltaDirection = normalize(dir) * delta;',
		'    ',
		'    vec3 Step = dir / steps;',
		'    ',
		'    float deltaDirectionLength = length(deltaDirection);',
		'    //vec4 vpos = frontColor;  // currentPosition',
		'    //vec3 Step = dir/uStepsF; // steps',
		'    //Start the ray casting from the front position.',
		'    vec3 currentPosition = frontPos;',
		'    //The color accumulator.',
		'    vec4 accumulatedColor = vec4(0.0);',
		'    //The alpha value accumulated so far.',
		'    float accumulatedAlpha = 0.0;',
		'    ',
		'    //How long has the ray travelled so far.',
		'    float accumulatedLength = 0.0;',
		'    ',
		'    //If we have twice as many samples, we only need ~1/2 the alpha per sample.',
		'    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.',
		'    float alphaScaleFactor = 28.8 * delta;',
		'    ',
		'    vec4 colorSample = vec4(0.0);',
		'    vec4 sample = vec4(0.0); ',
		'    vec4 grayValue;',
		'    float alphaSample;',
		'    float alphaCorrection = 1.0;',
		'    ',
		'    //Perform the ray marching iterations',
		'    for(int i = 0; i < MAX_STEPS; i++) {       ',
		'        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)      ',
		'            break;',
		'        if(accumulatedColor.a>=1.0) ',
		'            break;',
		'        grayValue = getVolumeValue(currentPosition); ',
		'        if(grayValue.z < 0.05 || ',
		'           grayValue.x < 0.0 ||',
		'           grayValue.x > 1.0)  ',
		'            accumulatedColor = vec4(0.0);     ',
		'        else { ',
		'            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;',
		'            colorSample.xyz = grayValue.xyz;',
		'            //colorSample.w = alphaScaleFactor;',
		'            colorSample.w = 0.1;',
		'              ',
		'            //sample.a = colorSample.a * 40.0 * (1.0 / steps);',
		'            sample.a = colorSample.a;',
		'            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xyz * sample.a; ',
		'             ',
		'            accumulatedColor += sample; ',
		'        }    ',
		'   ',
		'        //Advance the ray.',
		'        //currentPosition.xyz += deltaDirection;',
		'        currentPosition.xyz += Step;',
		'   ',
		'         ',
		'    } ',
		'    gl_FragColor = accumulatedColor;',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassNormalFusion = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"darkness" : { type: "f", value: -1 },
		"uSteps" : { type: "f", value: -1 },
		"uSetViewMode" : { type: "i", value: 0 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uSosThresholdBot" : { type: "f", value: -1 },
		"uSosThresholdTop" : { type: "f", value: -1 },
		"uAttenThresholdBot" : { type: "f", value: -1 },
		"uAttenThresholdTop" : { type: "f", value: -1 },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"l" : { type: "f", value: -1 },
		}
	]),
	vertexShader: [
		'precision mediump int;',
		'precision mediump float;',
		'attribute vec4 vertColor;',
		'varying vec4 frontColor;',
		'varying vec4 pos;',
		'void main(void)',
		'{',
		'    frontColor = vertColor;',
		'    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
		'    gl_Position = pos;',
		'}'].join("\n"),
	fragmentShader: [
		'precision mediump int;',
		'precision mediump float;',
		'varying vec4 frontColor;',
		'varying vec4 pos;',
		'uniform sampler2D uBackCoord;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uNumberOfSlices;',
		'uniform float uOpacityVal;',
		'uniform float uSlicesOverX;',
		'uniform float uSlicesOverY;',
		'uniform float darkness;',
		'uniform float uSteps;',
		'uniform int uSetViewMode;',
		'uniform float uMinGrayVal;',
		'uniform float uMaxGrayVal;',
		'uniform float uSosThresholdBot;',
		'uniform float uSosThresholdTop;',
		'uniform float uAttenThresholdBot;',
		'uniform float uAttenThresholdTop;',
		'uniform float uSlicemapWidth;',
		'uniform float l;',
		'//Acts like a texture3D using Z slices and trilinear filtering.',
		'vec3 getVolumeValue(vec3 volpos) {',
		'  float s1Original, s2Original, s1, s2;',
		'  float dx1, dy1;',
		'  vec2 texpos1,texpos2;',
		'  float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'  s1Original = floor(volpos.z*(uNumberOfSlices));',
		'  int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'  s1 = mod(s1Original, slicesPerSprite);',
		'  dx1 = fract(s1/uSlicesOverX);',
		'  dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'  texpos1.x = dx1+(volpos.x/uSlicesOverX);',
		'  texpos1.y = dy1+(volpos.y/uSlicesOverY);',
		'  vec3 value = vec3(0.0,0.0,0.0);',
		'  <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'      if( tex1Index == <%=i%> )',
		'      {',
		'          value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;',
		'      }',
		'      <% if( i < maxTexturesNumber-1 ) { %>',
		'          else',
		'      <% } %>',
		'  <% } %>',
		'  return value;',
		'}',
		'// Compute the Normal around the current voxel',
		'vec3 getNormal(vec3 at) {',
		'  float xw = uSlicemapWidth / uSlicesOverX;',
		'  float yw = uSlicemapWidth / uSlicesOverY;',
		'  float zw = uNumberOfSlices;',
		'  float fSliceLower, fSliceUpper, s1, s2;',
		'  float dx1, dy1, dx2, dy2;',
		'  int iTexLowerIndex, iTexUpperIndex;',
		'  vec2 texpos1,texpos2;',
		'  float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'  fSliceLower = floor(at.z*uNumberOfSlices); // z value is between 0 and 1. Multiplying the total number of slices',
		'                                             // gives the position in between. By flooring the value, you get the lower',
		'                                             // slice position.',
		'  fSliceUpper = min(fSliceLower + 1.0, uNumberOfSlices); // return the mininimum between the two values',
		'                                                         // act as a upper clamp.',
		'  // At this point, we get our lower slice and upper slice',
		'  // Now we need to get which texture image contains our slice.',
		'  iTexLowerIndex = int(floor(fSliceLower / slicesPerSprite));',
		'  iTexUpperIndex = int(floor(fSliceUpper / slicesPerSprite));',
		'  // mod returns the value of x modulo y. This is computed as x - y * floor(x/y).',
		'  s1 = mod(fSliceLower, slicesPerSprite); // returns the index of slice in slicemap',
		'  s2 = mod(fSliceUpper, slicesPerSprite);',
		'  dx1 = fract(s1/uSlicesOverX);',
		'  dy1 = floor(s1/uSlicesOverY)/uSlicesOverY; // first term is the row within the slicemap',
		'                                             // second division is normalize along y-axis',
		'  dx2 = fract(s2/uSlicesOverX);',
		'  dy2 = floor(s2/uSlicesOverY)/uSlicesOverY; // first term is the row within the slicemap',
		'                                             // second division is normalize along y-axis',
		'  float weight = at.z - floor(at.z);',
		'  float w1 = at.z - floor(at.z);',
		'  float w0 = (at.z - (1.0/zw)) - floor(at.z);',
		'  float w2 = (at.z + (1.0/zw)) - floor(at.z);',
		'  float fx, fy, fz;',
		'  float L0, L1, L2, L3, L4, L5, L6, L7, L8;',
		'  float H0, H1, H2, H3, H4, H5, H6, H7, H8;',
		'  <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'      if( iTexLowerIndex == <%=i%> )',
		'      {',
		'          texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);',
		'          L0 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);',
		'          L1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);',
		'          L2 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);',
		'          L3 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);',
		'          L4 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);',
		'          L5 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);',
		'          L6 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);',
		'          L7 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);',
		'          L8 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'      }',
		'      if( iTexUpperIndex == <%=i%> ) {',
		'          texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);',
		'          H0 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);',
		'          H1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);',
		'          H2 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);',
		'          H3 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);',
		'          H4 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);',
		'          H5 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);',
		'          H6 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);',
		'          H7 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'          texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);',
		'          texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);',
		'          H8 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'      }',
		'  <% } %>',
		'  // we need to get interpolation of 2 x points',
		'  // x direction',
		'  // -1 -3 -1   0  0  0   1  3  1',
		'  // -3 -6 -3   0  0  0   3  6  3',
		'  // -1 -3 -1   0  0  0   1  3  1',
		'  // y direction',
		'  //  1  3  1   3  6  3   1  3  1',
		'  //  0  0  0   0  0  0   0  0  0',
		'  // -1 -3 -1  -3 -6 -3  -1 -3 -1',
		'  // z direction',
		'  // -1  0  1   -3  0  3   -1  0  1',
		'  // -3  0  3   -6  0  6   -3  0  3',
		'  // -1  0  1   -3  0  3   -1  0  1',
		'  fx =  ((w0 * (H0 - L0)) + L0) * -1.0;',
		'  fx += ((w1 * (H0 - L0)) + L0) * -3.0;',
		'  fx += ((w2 * (H0 - L0)) + L0) * -1.0;',
		'  fx += ((w0 * (H3 - L3)) + L3) * -3.0;',
		'  fx += ((w1 * (H3 - L3)) + L3) * -6.0;',
		'  fx += ((w2 * (H3 - L3)) + L3) * -3.0;',
		'  fx += ((w0 * (H6 - L6)) + L6) * -1.0;',
		'  fx += ((w1 * (H6 - L6)) + L6) * -3.0;',
		'  fx += ((w2 * (H6 - L6)) + L6) * -1.0;',
		'  fx += ((w0 * (H1 - L1)) + L1) * 0.0;',
		'  fx += ((w1 * (H1 - L1)) + L1) * 0.0;',
		'  fx += ((w2 * (H1 - L1)) + L1) * 0.0;',
		'  fx += ((w0 * (H4 - L4)) + L4) * 0.0;',
		'  fx += ((w1 * (H4 - L4)) + L4) * 0.0;',
		'  fx += ((w2 * (H4 - L4)) + L4) * 0.0;',
		'  fx += ((w0 * (H7 - L7)) + L7) * 0.0;',
		'  fx += ((w1 * (H7 - L7)) + L7) * 0.0;',
		'  fx += ((w2 * (H7 - L7)) + L7) * 0.0;',
		'  fx += ((w0 * (H2 - L2)) + L2) * 1.0;',
		'  fx += ((w1 * (H2 - L2)) + L2) * 3.0;',
		'  fx += ((w2 * (H2 - L2)) + L2) * 1.0;',
		'  fx += ((w0 * (H5 - L5)) + L5) * 3.0;',
		'  fx += ((w1 * (H5 - L5)) + L5) * 6.0;',
		'  fx += ((w2 * (H5 - L5)) + L5) * 3.0;',
		'  fx += ((w0 * (H8 - L8)) + L8) * 1.0;',
		'  fx += ((w1 * (H8 - L8)) + L8) * 3.0;',
		'  fx += ((w2 * (H8 - L8)) + L8) * 1.0;',
		'  fy =  ((w0 * (H0 - L0)) + L0) * 1.0;',
		'  fy += ((w1 * (H0 - L0)) + L0) * 3.0;',
		'  fy += ((w2 * (H0 - L0)) + L0) * 1.0;',
		'  fy += ((w0 * (H3 - L3)) + L3) * 0.0;',
		'  fy += ((w1 * (H3 - L3)) + L3) * 0.0;',
		'  fy += ((w2 * (H3 - L3)) + L3) * 0.0;',
		'  fy += ((w0 * (H6 - L6)) + L6) * -1.0;',
		'  fy += ((w1 * (H6 - L6)) + L6) * -3.0;',
		'  fy += ((w2 * (H6 - L6)) + L6) * -1.0;',
		'  fy += ((w0 * (H1 - L1)) + L1) * 3.0;',
		'  fy += ((w1 * (H1 - L1)) + L1) * 6.0;',
		'  fy += ((w2 * (H1 - L1)) + L1) * 3.0;',
		'  fy += ((w0 * (H4 - L4)) + L4) * 0.0;',
		'  fy += ((w1 * (H4 - L4)) + L4) * 0.0;',
		'  fy += ((w2 * (H4 - L4)) + L4) * 0.0;',
		'  fy += ((w0 * (H7 - L7)) + L7) * -3.0;',
		'  fy += ((w1 * (H7 - L7)) + L7) * -6.0;',
		'  fy += ((w2 * (H7 - L7)) + L7) * -3.0;',
		'  fy += ((w0 * (H2 - L2)) + L2) * 1.0;',
		'  fy += ((w1 * (H2 - L2)) + L2) * 3.0;',
		'  fy += ((w2 * (H2 - L2)) + L2) * 1.0;',
		'  fy += ((w0 * (H5 - L5)) + L5) * 0.0;',
		'  fy += ((w1 * (H5 - L5)) + L5) * 0.0;',
		'  fy += ((w2 * (H5 - L5)) + L5) * 0.0;',
		'  fy += ((w0 * (H8 - L8)) + L8) * -1.0;',
		'  fy += ((w1 * (H8 - L8)) + L8) * -3.0;',
		'  fy += ((w2 * (H8 - L8)) + L8) * -1.0;',
		'  fz =  ((w0 * (H0 - L0)) + L0) * -1.0;',
		'  fz += ((w1 * (H0 - L0)) + L0) * 0.0;',
		'  fz += ((w2 * (H0 - L0)) + L0) * 1.0;',
		'  fz += ((w0 * (H3 - L3)) + L3) * -3.0;',
		'  fz += ((w1 * (H3 - L3)) + L3) * 0.0;',
		'  fz += ((w2 * (H3 - L3)) + L3) * 3.0;',
		'  fz += ((w0 * (H6 - L6)) + L6) * -1.0;',
		'  fz += ((w1 * (H6 - L6)) + L6) * 0.0;',
		'  fz += ((w2 * (H6 - L6)) + L6) * 1.0;',
		'  fz += ((w0 * (H1 - L1)) + L1) * -3.0;',
		'  fz += ((w1 * (H1 - L1)) + L1) * 0.0;',
		'  fz += ((w2 * (H1 - L1)) + L1) * 3.0;',
		'  fz += ((w0 * (H4 - L4)) + L4) * -6.0;',
		'  fz += ((w1 * (H4 - L4)) + L4) * 0.0;',
		'  fz += ((w2 * (H4 - L4)) + L4) * 6.0;',
		'  fz += ((w0 * (H7 - L7)) + L7) * -3.0;',
		'  fz += ((w1 * (H7 - L7)) + L7) * 0.0;',
		'  fz += ((w2 * (H7 - L7)) + L7) * 3.0;',
		'  fz += ((w0 * (H2 - L2)) + L2) * -1.0;',
		'  fz += ((w1 * (H2 - L2)) + L2) * 0.0;',
		'  fz += ((w2 * (H2 - L2)) + L2) * 1.0;',
		'  fz += ((w0 * (H5 - L5)) + L5) * -3.0;',
		'  fz += ((w1 * (H5 - L5)) + L5) * 0.0;',
		'  fz += ((w2 * (H5 - L5)) + L5) * 3.0;',
		'  fz += ((w0 * (H8 - L8)) + L8) * -1.0;',
		'  fz += ((w1 * (H8 - L8)) + L8) * 0.0;',
		'  fz += ((w2 * (H8 - L8)) + L8) * 1.0;',
		'  vec3 n = vec3( fx/27.0 , fy/27.0 , fz/27.0 );',
		'  return n;',
		'}',
		'// returns intensity of reflected ambient lighting',
		'const vec3 u_intensity = vec3(0.1, 0.1, 0.1);',
		'vec3 ambientLighting(vec3 lightColor) {',
		'    vec3 u_matAmbientReflectance = lightColor;',
		'    const vec3 u_lightAmbientIntensity = u_intensity;',
		'    return u_matAmbientReflectance * u_lightAmbientIntensity;',
		'}',
		'// returns intensity of diffuse reflection',
		'vec3 diffuseLighting(in vec3 N, in vec3 L, vec3 lightColor) {',
		'    vec3 u_matDiffuseReflectance = lightColor;',
		'    const vec3 u_lightDiffuseIntensity = vec3(0.6, 0.6, 0.6);',
		'    // calculation as for Lambertian reflection',
		'    float diffuseTerm = dot(N, L);',
		'    if (diffuseTerm > 1.0) {',
		'        diffuseTerm = 1.0;',
		'    } else if (diffuseTerm < 0.0) {',
		'        diffuseTerm = 0.0;',
		'    }',
		'    return u_matDiffuseReflectance * u_lightDiffuseIntensity * diffuseTerm;',
		'}',
		'// returns intensity of specular reflection',
		'vec3 specularLighting(in vec3 N, in vec3 L, in vec3 V, vec3 lightColor) {',
		'    float specularTerm = 0.0;',
		'    // const vec3 u_lightSpecularIntensity = vec3(0, 1, 0);',
		'    const vec3 u_lightSpecularIntensity = u_intensity;',
		'    vec3 u_matSpecularReflectance = lightColor;',
		'    const float u_matShininess = 5.0;',
		'   // calculate specular reflection only if',
		'   // the surface is oriented to the light source',
		'   if(dot(N, L) > 0.0)',
		'   {',
		'      vec3 e = normalize(-V);',
		'      vec3 r = normalize(-reflect(L, N));',
		'      specularTerm = pow(max(dot(r, e), 0.0), u_matShininess);',
		'   }',
		'   return u_matSpecularReflectance * u_lightSpecularIntensity * specularTerm;',
		'}',
		'void main(void) {',
		'    const int uStepsI = 256;',
		'    vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0;',
		'    vec4 backColor = texture2D(uBackCoord,texC);',
		'    vec3 dir = backColor.rgb - frontColor.rgb;',
		'    vec4 vpos = frontColor;',
		'    vec3 posAlongN;',
		'    vec3 Step = dir/uSteps;',
		'    vec4 accum = vec4(0, 0, 0, 0);',
		'    vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);',
		'    vec4 colorValue = vec4(0, 0, 0, 0);',
		'    float opacityFactor = uOpacityVal;',
		'    vec3 surfColor = vec3(0.45);',
		'    vec3 lightPos[3];',
		'    lightPos[0] = vec3(1, 1, 1);',
		'    lightPos[1] = vec3(-1, -1, -1);',
		'    lightPos[2] = vec3(1, 1, -1);',
		'    for(int i = 0; i < uStepsI; i++) {',
		'        vec3 gray_val = getVolumeValue(vpos.xyz).xyz;',
		'        if(gray_val.z < 0.05 ||',
		'           gray_val.x < uMinGrayVal ||',
		'           gray_val.x > uMaxGrayVal)',
		'            colorValue = vec4(0.0);',
		'        else {',
		'            colorValue.x = (darkness * 2.0 - gray_val.x) * l * 0.4;',
		'            colorValue.w = 0.1;',
		'            vec3 V = normalize(cameraPosition - vpos.xyz);',
		'            vec3 N = normalize(getNormal(vpos.xyz));',
		'            vec3 normStep = N / uSteps;',
		'            posAlongN = vpos.xyz;',
		'            for (int j = 0; j < 72; j++) {',
		'              if (gray_val.r > uSosThresholdBot && gray_val.r < uSosThresholdTop) {',
		'                surfColor = vec3(0.8, 0.2, 0.0);',
		'                break;',
		'              }',
		'              if (gray_val.g > uAttenThresholdBot && gray_val.g < uAttenThresholdTop) {',
		'                surfColor = vec3(0.0, 0.8, 0.0);',
		'                break;',
		'              }',
		'              gray_val = getVolumeValue(posAlongN).xyz;',
		'              posAlongN.xyz += normStep;',
		'            }',
		'            for(int light_i = 0; light_i < 3; ++light_i) {',
		'              vec3 L = normalize(lightPos[light_i] - vpos.xyz);',
		'              vec3 Iamb = ambientLighting(surfColor);',
		'              vec3 Idif = diffuseLighting(N, L, surfColor);',
		'              vec3 Ispe = specularLighting(N, L, V, surfColor);',
		'              sample.rgb += (Iamb + Idif + Ispe);',
		'            }',
		'            sample.a = 1.0;',
		'            accum += sample;',
		'            if(accum.a>=1.0)',
		'               break;',
		'        }',
		'        //advance the current position',
		'        vpos.xyz += Step;',
		'        if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)',
		'            break;',
		'    }',
		'    gl_FragColor = accum;',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassSoebel = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"darkness" : { type: "f", value: -1 },
		"uLightPos" : { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) },
		"uSetViewMode" : { type: "i", value: 0 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"l" : { type: "f", value: -1 },
		"s" : { type: "f", value: -1 },
		"hMin" : { type: "f", value: -1 },
		"hMax" : { type: "f", value: -1 },
		}
	]),
	vertexShader: [
		'precision mediump int;',
		'precision mediump float;',
		'attribute vec4 vertColor;',
		'varying vec4 frontColor;',
		'varying vec4 pos;',
		'void main(void)',
		'{',
		'    frontColor = vertColor;',
		'    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
		'    gl_Position = pos;',
		'}'].join("\n"),
	fragmentShader: [
		'// This is an experimental shader to implement',
		'// blinn phong shading model.',
		'// In this example, I use the USCT breast model',
		'// with a total of 144 slices as the dataset.',
		'// Hence the gradient operator is divided by 144 for',
		'// a single unit. Uncomment line 271 to see the normals',
		'// calculated by the gradient operator function.',
		'precision mediump int;',
		'precision mediump float;',
		'varying vec4 frontColor;',
		'varying vec4 pos;',
		'uniform sampler2D uBackCoord;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uNumberOfSlices;',
		'uniform float uOpacityVal;',
		'uniform float uSlicesOverX;',
		'uniform float uSlicesOverY;',
		'uniform float darkness;',
		'uniform vec3 uLightPos;',
		'uniform int uSetViewMode;',
		'uniform float uMinGrayVal;',
		'uniform float uMaxGrayVal;',
		'uniform float uSlicemapWidth;',
		'uniform float l;',
		'uniform float s;',
		'uniform float hMin;',
		'uniform float hMax;',
		'float xw = uSlicemapWidth / uSlicesOverX;',
		'float yw = uSlicemapWidth / uSlicesOverY;',
		'float zw = uNumberOfSlices;',
		'//Acts like a texture3D using Z slices and trilinear filtering.',
		'vec3 getVolumeValue(vec3 volpos)',
		'{',
		'    float s1Original, s2Original, s1, s2;',
		'    float dx1, dy1;',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    s1Original = floor(volpos.z*uNumberOfSlices);',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    texpos1.x = dx1+(volpos.x/uSlicesOverX);',
		'    texpos1.y = dy1+(volpos.y/uSlicesOverY);',
		'    vec3 value = vec3(0.0,0.0,0.0);',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;',
		'        }',
		'        <% if( i < maxTexturesNumber-1 ) { %>',
		'            else',
		'        <% } %>',
		'    <% } %>',
		'    return value;',
		'}',
		'// Compute the Normal around the current voxel',
		'vec3 getNormal(vec3 at)',
		'{',
		'    float fSliceLower, fSliceUpper, s1, s2;',
		'    float dx1, dy1, dx2, dy2;',
		'    int iTexLowerIndex, iTexUpperIndex;',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    fSliceLower = floor(at.z*uNumberOfSlices); // z value is between 0 and 1. Multiplying the total number of slices',
		'                                               // gives the position in between. By flooring the value, you get the lower',
		'                                               // slice position.',
		'    fSliceUpper = min(fSliceLower + 1.0, uNumberOfSlices); // return the mininimum between the two values',
		'                                                           // act as a upper clamp.',
		'    // At this point, we get our lower slice and upper slice',
		'    // Now we need to get which texture image contains our slice.',
		'    iTexLowerIndex = int(floor(fSliceLower / slicesPerSprite));',
		'    iTexUpperIndex = int(floor(fSliceUpper / slicesPerSprite));',
		'    // mod returns the value of x modulo y. This is computed as x - y * floor(x/y).',
		'    s1 = mod(fSliceLower, slicesPerSprite); // returns the index of slice in slicemap',
		'    s2 = mod(fSliceUpper, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY; // first term is the row within the slicemap',
		'                                               // second division is normalize along y-axis',
		'    dx2 = fract(s2/uSlicesOverX);',
		'    dy2 = floor(s2/uSlicesOverY)/uSlicesOverY; // first term is the row within the slicemap',
		'                                               // second division is normalize along y-axis',
		'    float weight = at.z - floor(at.z);',
		'    float w1 = at.z - floor(at.z);',
		'    float w0 = (at.z - (1.0/zw)) - floor(at.z);',
		'    float w2 = (at.z + (1.0/zw)) - floor(at.z);',
		'    float fx, fy, fz;',
		'    float L0, L1, L2, L3, L4, L5, L6, L7, L8;',
		'    float H0, H1, H2, H3, H4, H5, H6, H7, H8;',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( iTexLowerIndex == <%=i%> )',
		'        {',
		'            texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);',
		'            L0 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);',
		'            L1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);',
		'            L2 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);',
		'            L3 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);',
		'            L4 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);',
		'            L5 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);',
		'            L6 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);',
		'            L7 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);',
		'            L8 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'        }',
		'        if( iTexUpperIndex == <%=i%> ) {',
		'            texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);',
		'            H0 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);',
		'            H1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);',
		'            H2 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);',
		'            H3 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);',
		'            H4 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);',
		'            H5 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);',
		'            H6 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);',
		'            H7 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'            texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);',
		'            texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);',
		'            H8 = texture2D(uSliceMaps[<%=i%>],texpos1).x;',
		'        }',
		'    <% } %>',
		'    // we need to get interpolation of 2 x points',
		'    // x direction',
		'    // -1 -3 -1   0  0  0   1  3  1',
		'    // -3 -6 -3   0  0  0   3  6  3',
		'    // -1 -3 -1   0  0  0   1  3  1',
		'    // y direction',
		'    //  1  3  1   3  6  3   1  3  1',
		'    //  0  0  0   0  0  0   0  0  0',
		'    // -1 -3 -1  -3 -6 -3  -1 -3 -1',
		'    // z direction',
		'    // -1  0  1   -3  0  3   -1  0  1',
		'    // -3  0  3   -6  0  6   -3  0  3',
		'    // -1  0  1   -3  0  3   -1  0  1',
		'    fx =  ((w0 * (H0 - L0)) + L0) * -1.0;',
		'    fx += ((w1 * (H0 - L0)) + L0) * -3.0;',
		'    fx += ((w2 * (H0 - L0)) + L0) * -1.0;',
		'    fx += ((w0 * (H3 - L3)) + L3) * -3.0;',
		'    fx += ((w1 * (H3 - L3)) + L3) * -6.0;',
		'    fx += ((w2 * (H3 - L3)) + L3) * -3.0;',
		'    fx += ((w0 * (H6 - L6)) + L6) * -1.0;',
		'    fx += ((w1 * (H6 - L6)) + L6) * -3.0;',
		'    fx += ((w2 * (H6 - L6)) + L6) * -1.0;',
		'    fx += ((w0 * (H1 - L1)) + L1) * 0.0;',
		'    fx += ((w1 * (H1 - L1)) + L1) * 0.0;',
		'    fx += ((w2 * (H1 - L1)) + L1) * 0.0;',
		'    fx += ((w0 * (H4 - L4)) + L4) * 0.0;',
		'    fx += ((w1 * (H4 - L4)) + L4) * 0.0;',
		'    fx += ((w2 * (H4 - L4)) + L4) * 0.0;',
		'    fx += ((w0 * (H7 - L7)) + L7) * 0.0;',
		'    fx += ((w1 * (H7 - L7)) + L7) * 0.0;',
		'    fx += ((w2 * (H7 - L7)) + L7) * 0.0;',
		'    fx += ((w0 * (H2 - L2)) + L2) * 1.0;',
		'    fx += ((w1 * (H2 - L2)) + L2) * 3.0;',
		'    fx += ((w2 * (H2 - L2)) + L2) * 1.0;',
		'    fx += ((w0 * (H5 - L5)) + L5) * 3.0;',
		'    fx += ((w1 * (H5 - L5)) + L5) * 6.0;',
		'    fx += ((w2 * (H5 - L5)) + L5) * 3.0;',
		'    fx += ((w0 * (H8 - L8)) + L8) * 1.0;',
		'    fx += ((w1 * (H8 - L8)) + L8) * 3.0;',
		'    fx += ((w2 * (H8 - L8)) + L8) * 1.0;',
		'    fy =  ((w0 * (H0 - L0)) + L0) * 1.0;',
		'    fy += ((w1 * (H0 - L0)) + L0) * 3.0;',
		'    fy += ((w2 * (H0 - L0)) + L0) * 1.0;',
		'    fy += ((w0 * (H3 - L3)) + L3) * 0.0;',
		'    fy += ((w1 * (H3 - L3)) + L3) * 0.0;',
		'    fy += ((w2 * (H3 - L3)) + L3) * 0.0;',
		'    fy += ((w0 * (H6 - L6)) + L6) * -1.0;',
		'    fy += ((w1 * (H6 - L6)) + L6) * -3.0;',
		'    fy += ((w2 * (H6 - L6)) + L6) * -1.0;',
		'    fy += ((w0 * (H1 - L1)) + L1) * 3.0;',
		'    fy += ((w1 * (H1 - L1)) + L1) * 6.0;',
		'    fy += ((w2 * (H1 - L1)) + L1) * 3.0;',
		'    fy += ((w0 * (H4 - L4)) + L4) * 0.0;',
		'    fy += ((w1 * (H4 - L4)) + L4) * 0.0;',
		'    fy += ((w2 * (H4 - L4)) + L4) * 0.0;',
		'    fy += ((w0 * (H7 - L7)) + L7) * -3.0;',
		'    fy += ((w1 * (H7 - L7)) + L7) * -6.0;',
		'    fy += ((w2 * (H7 - L7)) + L7) * -3.0;',
		'    fy += ((w0 * (H2 - L2)) + L2) * 1.0;',
		'    fy += ((w1 * (H2 - L2)) + L2) * 3.0;',
		'    fy += ((w2 * (H2 - L2)) + L2) * 1.0;',
		'    fy += ((w0 * (H5 - L5)) + L5) * 0.0;',
		'    fy += ((w1 * (H5 - L5)) + L5) * 0.0;',
		'    fy += ((w2 * (H5 - L5)) + L5) * 0.0;',
		'    fy += ((w0 * (H8 - L8)) + L8) * -1.0;',
		'    fy += ((w1 * (H8 - L8)) + L8) * -3.0;',
		'    fy += ((w2 * (H8 - L8)) + L8) * -1.0;',
		'    fz =  ((w0 * (H0 - L0)) + L0) * -1.0;',
		'    fz += ((w1 * (H0 - L0)) + L0) * 0.0;',
		'    fz += ((w2 * (H0 - L0)) + L0) * 1.0;',
		'    fz += ((w0 * (H3 - L3)) + L3) * -3.0;',
		'    fz += ((w1 * (H3 - L3)) + L3) * 0.0;',
		'    fz += ((w2 * (H3 - L3)) + L3) * 3.0;',
		'    fz += ((w0 * (H6 - L6)) + L6) * -1.0;',
		'    fz += ((w1 * (H6 - L6)) + L6) * 0.0;',
		'    fz += ((w2 * (H6 - L6)) + L6) * 1.0;',
		'    fz += ((w0 * (H1 - L1)) + L1) * -3.0;',
		'    fz += ((w1 * (H1 - L1)) + L1) * 0.0;',
		'    fz += ((w2 * (H1 - L1)) + L1) * 3.0;',
		'    fz += ((w0 * (H4 - L4)) + L4) * -6.0;',
		'    fz += ((w1 * (H4 - L4)) + L4) * 0.0;',
		'    fz += ((w2 * (H4 - L4)) + L4) * 6.0;',
		'    fz += ((w0 * (H7 - L7)) + L7) * -3.0;',
		'    fz += ((w1 * (H7 - L7)) + L7) * 0.0;',
		'    fz += ((w2 * (H7 - L7)) + L7) * 3.0;',
		'    fz += ((w0 * (H2 - L2)) + L2) * -1.0;',
		'    fz += ((w1 * (H2 - L2)) + L2) * 0.0;',
		'    fz += ((w2 * (H2 - L2)) + L2) * 1.0;',
		'    fz += ((w0 * (H5 - L5)) + L5) * -3.0;',
		'    fz += ((w1 * (H5 - L5)) + L5) * 0.0;',
		'    fz += ((w2 * (H5 - L5)) + L5) * 3.0;',
		'    fz += ((w0 * (H8 - L8)) + L8) * -1.0;',
		'    fz += ((w1 * (H8 - L8)) + L8) * 0.0;',
		'    fz += ((w2 * (H8 - L8)) + L8) * 1.0;',
		'    vec3 n = vec3( fx/27.0 , fy/27.0 , fz/27.0 );',
		'    return n;',
		'}',
		'// returns intensity of reflected ambient lighting',
		'const vec3 lightColor = vec3(1.0, 0.88, 0.74);',
		'const vec3 u_intensity = vec3(0.1, 0.1, 0.1);',
		'vec3 ambientLighting()',
		'{',
		'    const vec3 u_matAmbientReflectance = lightColor;',
		'    const vec3 u_lightAmbientIntensity = u_intensity;',
		'    return u_matAmbientReflectance * u_lightAmbientIntensity;',
		'}',
		'// returns intensity of diffuse reflection',
		'vec3 diffuseLighting(in vec3 N, in vec3 L)',
		'{',
		'    const vec3 u_matDiffuseReflectance = lightColor;',
		'    const vec3 u_lightDiffuseIntensity = vec3(0.6, 0.6, 0.6);',
		'    // calculation as for Lambertian reflection',
		'    float diffuseTerm = dot(N, L);',
		'    if (diffuseTerm > 1.0) {',
		'        diffuseTerm = 1.0;',
		'    } else if (diffuseTerm < 0.0) {',
		'        diffuseTerm = 0.0;',
		'    }',
		'    return u_matDiffuseReflectance * u_lightDiffuseIntensity * diffuseTerm;',
		'}',
		'// returns intensity of specular reflection',
		'vec3 specularLighting(in vec3 N, in vec3 L, in vec3 V)',
		'{',
		'  float specularTerm = 0.0;',
		'    // const vec3 u_lightSpecularIntensity = vec3(0, 1, 0);',
		'    const vec3 u_lightSpecularIntensity = u_intensity;',
		'    const vec3 u_matSpecularReflectance = lightColor;',
		'    const float u_matShininess = 5.0;',
		'   // calculate specular reflection only if',
		'   // the surface is oriented to the light source',
		'   if(dot(N, L) > 0.0)',
		'   {',
		'      vec3 e = normalize(-V);',
		'      vec3 r = normalize(-reflect(L, N));',
		'      specularTerm = pow(max(dot(r, e), 0.0), u_matShininess);',
		'   }',
		'   return u_matSpecularReflectance * u_lightSpecularIntensity * specularTerm;',
		'}',
		'void main(void)',
		'{',
		'    const int uStepsI = 256;',
		'    const float uStepsF = float(uStepsI);',
		'    vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0;',
		'    vec4 backColor = texture2D(uBackCoord,texC);',
		'    vec3 dir = backColor.rgb - frontColor.rgb;',
		'    vec4 vpos = frontColor;',
		'    vec3 Step = dir/uStepsF;',
		'    vec4 accum = vec4(0, 0, 0, 0);',
		'    vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);',
		'    vec4 colorValue = vec4(0, 0, 0, 0);',
		'    float opacityFactor = uOpacityVal;',
		'    vec3 lightPos[3];',
		'    lightPos[0] = vec3(1, 1, 1);',
		'    lightPos[1] = vec3(-1, -1, -1);',
		'    lightPos[2] = vec3(1, 1, -1);',
		'    // float xsqu;',
		'    // float ysqu;',
		'    // float distanceFromCenter;',
		'    for(int i = 0; i < uStepsI; i++) {',
		'      // xsqu = (0.5 - vpos.x) * (0.5 - vpos.x);',
		'      // ysqu = (0.5 - vpos.y) * (0.5 - vpos.y);',
		'      // distanceFromCenter = sqrt(xsqu + ysqu);',
		'      //',
		'      // if (distanceFromCenter < 0.4534 && vpos.z > 0.1 && vpos.z < 0.9) {',
		'        vec3 gray_val = getVolumeValue(vpos.xyz);',
		'        /************************************/',
		'        /*         Mean filtering           */',
		'        /************************************/',
		'        if (gray_val.x > uMinGrayVal && gray_val.x < uMaxGrayVal) {',
		'          float sum_gray_val = 0.0;',
		'          int mask_size = 3;',
		'          vec3 offset;',
		'          vec3 curDotPos;',
		'          for(int m_i = 0; m_i < 3; ++m_i) { // 3 = mask_size',
		'            for(int j = 0; j < 3; ++j) {',
		'              for(int k = 0; k < 3; ++k) {',
		'                offset = vec3((float(m_i) - 1.0) / xw, // 1.0 = (int)mask_size / 2',
		'                              (float(j) - 1.0) / yw,',
		'                              (float(k) - 1.0) / zw);',
		'                curDotPos = vpos.xyz + offset;',
		'                sum_gray_val += getVolumeValue(curDotPos).x;',
		'              }',
		'            }',
		'          }',
		'          gray_val.x = sum_gray_val / 27.0; // 27.0 = pow(mask_size, 3)',
		'        } // end of Mean filtering',
		'        if(gray_val.z < 0.05 ||',
		'           gray_val.x < uMinGrayVal ||',
		'           gray_val.x > uMaxGrayVal)',
		'            colorValue = vec4(0.0);',
		'        else {',
		'            colorValue.x = (darkness * 2.0 - gray_val.x) * l * 0.4;',
		'            //colorValue.x = gray_val.x;',
		'            colorValue.w = 0.1;',
		'            if ( uSetViewMode == 1 ) {',
		'              vec3 V = normalize(cameraPosition - vpos.xyz);',
		'              vec3 N = normalize(getNormal(vpos.xyz));',
		'              for(int light_i = 0; light_i < 3; ++light_i) {',
		'                vec3 L = normalize(lightPos[light_i] - vpos.xyz);',
		'                vec3 Iamb = ambientLighting();',
		'                vec3 Idif = diffuseLighting(N, L);',
		'                vec3 Ispe = specularLighting(N, L, V);',
		'                sample.rgb += (Iamb + Idif + Ispe);',
		'              }',
		'              sample.a = 1.0;',
		'            } else {',
		'                sample.rgb = (1.0 - accum.a) * colorValue.xxx * sample.a;',
		'                sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF);',
		'            }',
		'            accum += sample;',
		'            if(accum.a>=1.0)',
		'               break;',
		'        }',
		'      // }',
		'        //advance the current position',
		'        vpos.xyz += Step;',
		'        if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)',
		'            break;',
		'    }',
		'    gl_FragColor = accum;',
		'}'].join("\n")
};
window.VRC.Core.prototype._shaders.secondPassTrilinearRGB = {
	uniforms: THREE.UniformsUtils.merge([
		{
		"uBackCoord" : { type: "t", value: null },
		"uTransferFunction" : { type: "t", value: null },
		"uSliceMaps" : { type: "tv", value: [] },
		"uSlicemapWidth" : { type: "f", value: -1 },
		"uNumberOfSlices" : { type: "f", value: -1 },
		"uMinGrayVal" : { type: "f", value: -1 },
		"uMaxGrayVal" : { type: "f", value: -1 },
		"uOpacityVal" : { type: "f", value: -1 },
		"uColorVal" : { type: "f", value: -1 },
		"uAbsorptionModeIndex" : { type: "f", value: -1 },
		"uSlicesOverX" : { type: "f", value: -1 },
		"uSlicesOverY" : { type: "f", value: -1 },
		"uSteps" : { type: "f", value: -1 },
		"uRatio" : { type: "f", value: -1 },
		"uAvailable_textures_number" : { type: "i", value: 0 },
		}
	]),
	vertexShader: [
		'varying vec3 worldSpaceCoords;',
		'varying vec4 projectedCoords;',
		' ',
		'void main()',
		'{',
		'    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;',
		'    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
		'}'].join("\n"),
	fragmentShader: [
		'#ifdef GL_FRAGMENT_PRECISION_HIGH ',
		' // highp is supported ',
		' precision highp int; ',
		' precision highp float; ',
		'#else ',
		' // high is not supported ',
		' precision mediump int; ',
		' precision mediump float; ',
		'#endif ',
		'// Passed from vertex',
		'varying vec3 worldSpaceCoords; ',
		'varying vec4 projectedCoords; ',
		'// Passed from core',
		'uniform sampler2D uBackCoord; ',
		'uniform sampler2D uTransferFunction;',
		'uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];',
		'uniform float uSlicemapWidth;',
		'// Assuming a bounding box of 512x512x512',
		'// ceil( sqrt(3) * 512 ) = 887',
		'const int MAX_STEPS = 887;',
		'// Application specific parameters',
		'uniform float uNumberOfSlices; ',
		'uniform float uMinGrayVal; ',
		'uniform float uMaxGrayVal;',
		'uniform float uOpacityVal; ',
		'uniform float uColorVal; ',
		'uniform float uAbsorptionModeIndex;',
		'uniform float uSlicesOverX; ',
		'uniform float uSlicesOverY; ',
		'uniform float uSteps;',
		'uniform float uRatio;',
		'// uniform int uAvailable_textures_number;',
		'vec4 getVolumeValue(vec3 volpos)',
		'{',
		'    //if (volpos.z < 0.5)',
		'    //    return vec4(0.0);',
		'    float s1Original, s2Original, s1, s2; ',
		'    float dx1, dy1; ',
		'    float dx2, dy2; ',
		'    // float value; ',
		'    vec2 texpos1,texpos2;',
		'    float slicesPerSprite = uSlicesOverX * uSlicesOverY;',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float delta = 1.0 / (sliceSizeX * uRatio);',
		'    ',
		'    float adapted_x, adapted_y, adapted_z;',
		'    //adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;',
		'    //adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;',
		'    //adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);',
		'    ',
		'    adapted_x = volpos.x;',
		'    adapted_y = volpos.y;',
		'    //adapted_z = volpos.z;',
		'    adapted_z = 1.0 - (volpos.z * (1.0/uRatio));',
		'    s1Original = floor(adapted_z * uNumberOfSlices);',
		'    s2Original = s1Original + delta;',
		'    int tex1Index = int(floor(s1Original / slicesPerSprite));',
		'    int tex2Index = int(floor(s2Original / slicesPerSprite));',
		'    s1 = mod(s1Original, slicesPerSprite);',
		'    s2 = mod(s2Original, slicesPerSprite);',
		'    dx1 = fract(s1/uSlicesOverX);',
		'    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    dx2 = fract(s2/uSlicesOverX);',
		'    dy2 = floor(s2/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    texpos1.x = dx1+(adapted_x*sliceSizeX)/uSlicemapWidth;',
		'    texpos1.y = dy1+(adapted_y*sliceSizeY)/uSlicemapWidth;',
		'    ',
		'    texpos2.x = dx2+(adapted_x*sliceSizeX)/uSlicemapWidth;',
		'    texpos2.y = dy2+(adapted_y*sliceSizeY)/uSlicemapWidth;',
		' ',
		' ',
		'    vec4 value1, value2;',
		'    ',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( tex1Index == <%=i%> )',
		'        {',
		'            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'        if( tex2Index == <%=i%> )',
		'        {',
		'            value2 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;',
		'        }',
		'    <% } %>',
		'    ',
		'    //return vec4( (value1 + value2) * 0.5);',
		'    ',
		'    ',
		'    return mix(value1, value2, fract(volpos.z* uNumberOfSlices));',
		'}',
		'float getTextureValue(int slicemapNo, vec2 texpos)',
		'{',
		'    float value = 0.0;',
		'    vec3 value_vec;',
		'    ',
		'    <% for(var i=0; i < maxTexturesNumber; i++) { %>',
		'        if( slicemapNo == <%=i%> )',
		'        {',
		'          value_vec = texture2D(uSliceMaps[<%=i%>],texpos).rgb;',
		'          //value = ((value_vec.r + value_vec.g + value_vec.b)/3.0);',
		'          //value = ((value_vec.r * 0.299)+(value_vec.g * 0.587)+(value_vec.b * 0.114));',
		'          value = value_vec.r;',
		'        }',
		'        <% if( i < maxTexturesNumber-1 ) { %>',
		'            else',
		'        <% } %>',
		'    <% } %>',
		'    ',
		'    return value;',
		'}',
		'float getValueTri(vec3 volpos)',
		'{',
		'    vec2 texpos1a, texpos1b, texpos1c, texpos1d, texpos2a, texpos2b, texpos2c, texpos2d;',
		'    float value1a, value1b, value1c, value1d, value2a, value2b, value2c, value2d, valueS;',
		'    float value1ab, value1cd, value1ac, value1bd, value2ab, value2cd, value2ac, value2bd, value1, value2;',
		'    float NOS = uNumberOfSlices;  //  abbreviation ',
		'    float slicesPerSlicemap = uSlicesOverX * uSlicesOverY; ',
		'    float sliceSizeX = uSlicemapWidth/uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth/uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    ',
		'    //  Slice selection',
		'    float sliceNo1 = floor(abs(volpos.z*NOS-0.5));  //  sliceNo1 stands for lower slice',
		'    float sliceNo2 = NOS-1.0-floor(abs(NOS-0.5-volpos.z*NOS));  //  sliceNo2 stands for upper slice',
		'    int slicemapNo1 = int(floor(sliceNo1 / slicesPerSlicemap));',
		'    int slicemapNo2 = int(floor(sliceNo2 / slicesPerSlicemap));',
		'    float s1 = mod(sliceNo1, slicesPerSlicemap);  // s1 stands for the sliceNo of lower slice in this map',
		'    float dx1 = fract(s1/uSlicesOverX);',
		'    float dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;',
		'    float s2 = mod(sliceNo2, slicesPerSlicemap);  // s2 stands for the sliceNo of upper slice in this map',
		'    float dx2 = fract(s2/uSlicesOverX);',
		'    float dy2 = floor(s2/uSlicesOverY)/uSlicesOverY;',
		'    ',
		'    /*',
		'    texpos1.x = dx1+volpos.x/uSlicesOverX;  // directly from texture2D',
		'    texpos1.y = dy1+volpos.y/uSlicesOverY;',
		'    texpos1.x = dx1+(floor(volpos.x*sliceSizeX)+0.5)/uSlicemapWidth;  //  NearestNeighbor in lower slice',
		'    texpos1.y = dy1+(floor(volpos.y*sliceSizeY)+0.5)/uSlicemapWidth;',
		'    */',
		'    ',
		'    // Four nearest pixels in lower slice',
		'    texpos1a.x = texpos1c.x = dx1+(floor(abs(volpos.x*sliceSizeX-0.5))+0.5)/uSlicemapWidth;  //  Trilinear',
		'    texpos1a.y = texpos1b.y = dy1+(floor(abs(volpos.y*sliceSizeY-0.5))+0.5)/uSlicemapWidth;',
		'    texpos1b.x = texpos1d.x = dx1+(sliceSizeX-1.0-floor(abs(sliceSizeX-0.5-volpos.x*sliceSizeX))+0.5)/uSlicemapWidth;',
		'    texpos1c.y = texpos1d.y = dy1+(sliceSizeY-1.0-floor(abs(sliceSizeY-0.5-volpos.y*sliceSizeY))+0.5)/uSlicemapWidth;',
		'    ',
		'    // Four nearest pixels in upper slice',
		'    texpos2a.x = texpos2c.x = dx2+(floor(abs(volpos.x*sliceSizeX-0.5))+0.5)/uSlicemapWidth;  //  Trilinear',
		'    texpos2a.y = texpos2b.y = dy2+(floor(abs(volpos.y*sliceSizeY-0.5))+0.5)/uSlicemapWidth;',
		'    texpos2b.x = texpos2d.x = dx2+(sliceSizeX-1.0-floor(abs(sliceSizeX-0.5-volpos.x*sliceSizeX))+0.5)/uSlicemapWidth;',
		'    texpos2c.y = texpos2d.y = dy2+(sliceSizeY-1.0-floor(abs(sliceSizeY-0.5-volpos.y*sliceSizeY))+0.5)/uSlicemapWidth;',
		'    // get texture values of these 8 pixels',
		'    value1a = getTextureValue(slicemapNo1, texpos1a);',
		'    value1b = getTextureValue(slicemapNo1, texpos1b);',
		'    value1c = getTextureValue(slicemapNo1, texpos1c);',
		'    value1d = getTextureValue(slicemapNo1, texpos1d);',
		'    value2a = getTextureValue(slicemapNo2, texpos2a);',
		'    value2b = getTextureValue(slicemapNo2, texpos2b);',
		'    value2c = getTextureValue(slicemapNo2, texpos2c);',
		'    value2d = getTextureValue(slicemapNo2, texpos2d);',
		'    ',
		'    // ratio calculation',
		'    float ratioX = volpos.x*sliceSizeX+0.5-floor(volpos.x*sliceSizeX+0.5);',
		'    float ratioY = volpos.y*sliceSizeY+0.5-floor(volpos.y*sliceSizeY+0.5);',
		'    float ratioZ = volpos.z*NOS+0.5-floor(volpos.z*NOS+0.5);',
		'    //float ratioZ = (volpos.z-(sliceNo1+0.5)/NOS) / (1.0/NOS);  // Another way to get ratioZ',
		'    ',
		'    ',
		'    //  Trilinear interpolation ',
		'    value1ab = value1a+ratioX*(value1b-value1a);',
		'    value1cd = value1c+ratioX*(value1d-value1c);',
		'    value1 = value1ab+ratioY*(value1cd-value1ab);',
		'    value2ab = value2a+ratioX*(value2b-value2a);',
		'    value2cd = value2c+ratioX*(value2d-value2c);',
		'    value2 = value2ab+ratioY*(value2cd-value2ab);',
		'    ',
		'    valueS = value1+ratioZ*(value2-value1);',
		'    ',
		'    ',
		'    // Do NO interpolation with empty voxels',
		'    if (value1a<=0.0 || value1b<=0.0 || value1c<=0.0 || value1d<=0.0 || value2a<=0.0 || value2b<=0.0 || value2c<=0.0 || value2d<=0.0)',
		'    {',
		'        if (value1a<=0.0 || value1c<=0.0 || value2a<=0.0 || value2c<=0.0)',
		'        {    ',
		'            value1ab = value1b;',
		'            value1cd = value1d;',
		'            value2ab = value2b;',
		'            value2cd = value2d;',
		'            ',
		'            if (value1b<=0.0 || value2b<=0.0)',
		'            {',
		'                value1 = value1d;',
		'                value2 = value2d;',
		'                ',
		'                if (value1d <= 0.0)',
		'                    valueS = value2;',
		'                else if (value2d <= 0.0)',
		'                    valueS = value1;',
		'                else',
		'                    valueS = value1+ratioZ*(value2-value1);',
		'            }',
		'            ',
		'            else if (value1d<=0.0 || value2d<=0.0)',
		'            {',
		'                value1 = value1b;',
		'                value2 = value2b;',
		'                valueS = value1+ratioZ*(value2-value1);',
		'            }',
		'            ',
		'            else',
		'            {',
		'                value1 = value1ab+ratioY*(value1cd-value1ab);',
		'                value2 = value2ab+ratioY*(value2cd-value2ab);',
		'                valueS = value1+ratioZ*(value2-value1);',
		'            }',
		'        }',
		'    ',
		'    ',
		'        else',
		'        {  // if (value1b<=0.0 || value1d<=0.0 || value2b<=0.0 || value2d<=0.0)',
		'            value1ab = value1a;',
		'            value1cd = value1c;',
		'            value2ab = value2a;',
		'            value2cd = value2c;',
		'            ',
		'            value1 = value1ab+ratioY*(value1cd-value1ab);',
		'            value2 = value2ab+ratioY*(value2cd-value2ab);',
		'            valueS = value1+ratioZ*(value2-value1);',
		'        }',
		'    ',
		'    }',
		'    ',
		'    ',
		'    /*',
		'    if (value1a<=0.0 || value1b<=0.0 || value1c<=0.0 || value1d<=0.0 || value2a<=0.0 || value2b<=0.0 || value2c<=0.0 || value2d<=0.0)',
		'        valueS = 0.0;',
		'    */',
		'    ',
		'    return valueS;',
		'}',
		'void main(void) {',
		' ',
		'    //Transform the coordinates it from [-1;1] to [0;1]',
		'    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,',
		'                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);',
		'    //The back position is the world space position stored in the texture.',
		'    vec3 backPos = texture2D(uBackCoord, texc).xyz;',
		'                ',
		'    //The front position is the world space position of the second render pass.',
		'    vec3 frontPos = worldSpaceCoords;',
		' ',
		'    //The direction from the front position to back position.',
		'    vec3 dir = backPos - frontPos;',
		'    float rayLength = length(dir);',
		'    //Calculate how long to increment in each step.',
		'    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;',
		'    //float steps = 256.0;',
		'    float delta = 1.0 / steps;',
		'    ',
		'    //The increment in each direction for each step.',
		'    vec3 deltaDirection = normalize(dir) * delta;',
		'    ',
		'    vec3 Step = dir / steps;',
		'    ',
		'    float deltaDirectionLength = length(deltaDirection);',
		'    //vec4 vpos = frontColor;  // currentPosition',
		'    //vec3 Step = dir/uStepsF; // steps',
		'    //Start the ray casting from the front position.',
		'    vec3 currentPosition = frontPos;',
		'    //The color accumulator.',
		'    vec4 accumulatedColor = vec4(0.0);',
		'    //The alpha value accumulated so far.',
		'    float accumulatedAlpha = 0.0;',
		'    ',
		'    //How long has the ray travelled so far.',
		'    float accumulatedLength = 0.0;',
		'    ',
		'    //If we have twice as many samples, we only need ~1/2 the alpha per sample.',
		'    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.',
		'    float alphaScaleFactor = 28.8 * delta;',
		'    ',
		'    vec4 colorSample = vec4(0.0);',
		'    vec4 sample = vec4(0.0); ',
		'    vec4 grayValue;',
		'    float alphaSample;',
		'    float alphaCorrection = 1.0;',
		'    ',
		'    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis',
		'    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis',
		'    float sm_delta = 1.0 / sliceSizeX;',
		'    ',
		'    //Perform the ray marching iterations',
		'    for(int i = 0; i < MAX_STEPS; i++) {       ',
		'        if(currentPosition.x > 1.0 ||',
		'           currentPosition.y > 1.0 ||',
		'           currentPosition.z > 1.0 ||',
		'           currentPosition.x < 0.0 ||',
		'           currentPosition.y < 0.0 ||',
		'           currentPosition.z < 0.0)',
		'            break;',
		'        if(accumulatedColor.a>=1.0) ',
		'            break;',
		'        //grayValue = getVolumeValue(currentPosition);',
		'        grayValue = vec4(getValueTri(currentPosition));',
		'        if(grayValue.z < 0.05 || ',
		'           grayValue.x <= uMinGrayVal ||',
		'           grayValue.x >= uMaxGrayVal)  ',
		'            accumulatedColor = vec4(0.0);     ',
		'        else { ',
		'            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;',
		'            colorSample.xyz = grayValue.xyz;',
		'            //colorSample.w = alphaScaleFactor;',
		'            colorSample.w = 0.1;',
		'              ',
		'            //sample.a = colorSample.a * 40.0 * (1.0 / steps);',
		'            sample.a = colorSample.a;',
		'            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xyz * sample.a; ',
		'             ',
		'            accumulatedColor += sample; ',
		'        }    ',
		'   ',
		'        //Advance the ray.',
		'        //currentPosition.xyz += deltaDirection;',
		'        currentPosition.xyz += Step;',
		'   ',
		'         ',
		'    } ',
		'    gl_FragColor = accumulatedColor;',
		'}'].join("\n")
};
