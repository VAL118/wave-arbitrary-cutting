function buildAxes(length){var axes=new THREE.Object3D;return axes.add(buildAxis(new THREE.Vector3(-length,-length,-length),new THREE.Vector3(3*length,-length,-length),16711680,!1)),axes.add(buildAxis(new THREE.Vector3(-length,-length,-length),new THREE.Vector3(2*-length,-length,-length),16711680,!0)),axes.add(buildAxis(new THREE.Vector3(-length,-length,-length),new THREE.Vector3(-length,3*length,-length),65280,!1)),axes.add(buildAxis(new THREE.Vector3(-length,-length,-length),new THREE.Vector3(-length,2*-length,-length),65280,!0)),axes.add(buildAxis(new THREE.Vector3(-length,-length,-length),new THREE.Vector3(-length,-length,3*length),255,!1)),axes.add(buildAxis(new THREE.Vector3(-length,-length,-length),new THREE.Vector3(-length,-length,2*-length),255,!0)),axes}function buildAxis(src,dst,colorHex,dashed){var mat,geom=new THREE.Geometry;return mat=dashed?new THREE.LineDashedMaterial({linewidth:1,color:colorHex,dashSize:3,gapSize:3}):new THREE.LineBasicMaterial({linewidth:1,color:colorHex}),geom.vertices.push(src.clone()),geom.vertices.push(dst.clone()),geom.computeLineDistances(),new THREE.Line(geom,mat,THREE.LinePieces)}window.VRC={},window.VRC.EventDispatcher=function(O){var me={};return me.class=this,me._functions=[],me._context=window,me.add=function(func,is_start){return me._functions.push({is_start:void 0==is_start||is_start,func:func}),me._functions.length-1},me.remove=function(index){delete me._functions[index]},me.get=function(index){return me._functions[index]},me.stop=function(index){me._functions[index].is_start=!1},me.start=function(index){me._functions[index].is_start=!0},me.isStart=function(index){return me._functions[index].is_start},me.call=function(value,context){var context=context||me._context;for(i in me._functions){var task=me._functions[i];task.is_start&&task.func.call(context,value)}},me.isEmpty=function(){return 0==me._functions.length},me.setConfig=function(O){for(prop in O)switch(prop){case"context":this._context=O[prop]}},me.Constructor=function(O){this.setConfig(O)},me.Constructor(O),me},window.VRC.AdaptationManager=function(){var me={};return me._core={},me._step=5,me._steps=2*me._step,me._onPostDrawFuncIndex=-1,me._onCameraChangeStartFuncIndex=-1,me._onCameraChangeEndFuncIndex=-1,me.init=function(core){me._core=core,me._onPostDrawFuncIndex=me._core.onPostDraw.add(function(fps){me.do(fps)}),me._onCameraChangeStartFuncIndex=me._core.onCameraChangeStart.add(function(){}),me._onCameraChangeEndFuncIndex=me._core.onCameraChangeEnd.add(function(){})},me.run=function(flag){flag?(me._core.onPostDraw.start(me._onPostDrawFuncIndex),me._core.onCameraChangeStart.start(me._onCameraChangeEndFuncIndex),me._core.onCameraChangeEnd.start(me._onCameraChangeStartFuncIndex)):(me._core.onPostDraw.stop(me._onPostDrawFuncIndex),me._core.onCameraChangeStart.stop(me._onCameraChangeEndFuncIndex),me._core.onCameraChangeEnd.stop(me._onCameraChangeStartFuncIndex))},me.pause=function(flag){flag?(me._core.onCameraChangeStart.stop(me._onCameraChangeEndFuncIndex),me._core.onPostDraw.stop(me._onPostDrawFuncIndex)):(me._core.onCameraChangeStart.start(me._onCameraChangeEndFuncIndex),me._core.onPostDraw.start(me._onPostDrawFuncIndex))},me.getNearestSurroundingsPossibleStep=function(steps){for(var delta=me._step,direction=me._step*(steps-me.getSteps())>0?1:-1,adaptationSteps=me.getSteps();adaptationSteps<me._core.getMaxStepsNumber();adaptationSteps+=direction)if(Math.abs(adaptationSteps-steps)<=delta){if(steps>adaptationSteps)return[adaptationSteps,adaptationSteps+me._step];if(steps>adaptationSteps)return[adaptationSteps-me._step,adaptationSteps];if(steps==adaptationSteps)return[adaptationSteps-me._step,adaptationSteps+me._step]}return[me._core.getMaxStepsNumber()-me._step,me._core.getMaxStepsNumber()]},me.decreaseSteps=function(){var nearestSurroundingsPossibleSteps=me.getNearestSurroundingsPossibleStep(me._core.getSteps());me._steps=nearestSurroundingsPossibleSteps[0]},me.increaseSteps=function(){var nearestSurroundingsPossibleSteps=me.getNearestSurroundingsPossibleStep(me._core.getSteps());me._steps=nearestSurroundingsPossibleSteps[1]},me.getSteps=function(){return me._steps},me.isRun=function(){var isRunOnPostDraw=me._core.onPostDraw.isStart(me._onPostDrawFuncIndex),isRunOnCameraChangeStart=me._core.onCameraChangeStart.isStart(me._onCameraChangeEndFuncIndex),isRunOnCameraChangeEnd=me._core.onCameraChangeEnd.isStart(me._onCameraChangeStartFuncIndex);return isRunOnPostDraw&&isRunOnCameraChangeStart&&isRunOnCameraChangeEnd},me.isPause=function(){var isRunOnPostDraw=me._core.onPostDraw.isStart(me._onPostDrawFuncIndex),isRunOnCameraChangeStart=me._core.onCameraChangeStart.isStart(me._onCameraChangeEndFuncIndex),isRunOnCameraChangeEnd=me._core.onCameraChangeEnd.isStart(me._onCameraChangeStartFuncIndex);return!isRunOnPostDraw&&!isRunOnCameraChangeStart&&isRunOnCameraChangeEnd},me._numberOfChanges=0,me.do=function(fps){fps<10&&me.getSteps()>2*me._step?(me._numberOfChanges--,-5==me._numberOfChanges&&(me.decreaseSteps(),me._numberOfChanges=0,me._core.setSteps(me.getSteps()))):fps>30&&me.getSteps()<me._core.getMaxStepsNumber()&&(me._numberOfChanges++,3==me._numberOfChanges&&(me.increaseSteps(),me._numberOfChanges=0,me._core.setSteps(me.getSteps())))},me},window.VRC.GeometryHelper=function(){var me={};return me.createBoxGeometry=function(geometryDimension,volumeSize,zFactor){for(var vertexPositions=[[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax/300*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax/300*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax/300*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax/300*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax/300*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax/300*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]]],vertexColors=[[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax/300],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax/300],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax/300],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax/300,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax/300,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax/300,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin]],positions=[],colors=[],i=0;i<vertexPositions.length;i++){var backCounter=vertexPositions.length-1-i,x=vertexPositions[backCounter][0],y=vertexPositions[backCounter][1],z=vertexPositions[backCounter][2]*zFactor,r=vertexColors[backCounter][0],g=vertexColors[backCounter][1],b=vertexColors[backCounter][2];positions.push(x),positions.push(y),positions.push(z),colors.push(r),colors.push(g),colors.push(b),colors.push(1)}var geometry=new THREE.BufferGeometry,bufferPositions=new Float32Array(positions);return geometry.addAttribute("position",new THREE.BufferAttribute(bufferPositions,3)),geometry.addAttribute("vertColor",new THREE.BufferAttribute(new Float32Array(colors),4)),geometry.computeBoundingBox(),geometry},me.isVisible=function(x0,y0,z0,x,y,z,camx,camy,camz){return camVecX=camx-x0,camVecY=camy-y0,camVecZ=camz-z0,ab=x*camVecX+y*camVecY+z*camVecZ,a=Math.sqrt(Math.pow(x,2)+Math.pow(y,2)+Math.pow(z,2)),b=Math.sqrt(Math.pow(camVecX,2)+Math.pow(camVecY,2)+Math.pow(camVecZ,2)),Math.acos(ab/(a*b))<1.57},me.createBoxGeometry1=function(geometryDimension,volumeSize,zFactor,aX,aY,aZ,bX,bY,bZ,cX,cY,cZ,dX,dY,dZ,camX,camY,camZ){bcX=bX+cX,bcY=bY+cY,bcZ=bZ+cZ,bdX=bX+dX,bdY=bY+dY,bdZ=bZ+dZ,adX=aX+dX,adY=aY+dY,adZ=aZ+dZ,acX=aX+cX,acY=aY+cY,acZ=aZ+cZ;var vertexPositions=[[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax/300*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax/300*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax/300*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax/300*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax/300*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin/300*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax/300*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax/300*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax/300*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]]],vertexColors=[[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax/300],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax/300],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax/300],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax/300],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax/300],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin/300],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax/300,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax/300,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax/300,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin]],vertexPositions=[[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]]],vertexColors=[[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin]];me.isVisible(0,0,.5,0,0,1.5,camX,camY,camZ)&&(vertexPositions[0]=[adX*volumeSize[0],adY*volumeSize[1],adZ*volumeSize[2]],vertexPositions[1]=[bdX*volumeSize[0],bdY*volumeSize[1],bdZ*volumeSize[2]],vertexPositions[2]=[bcX*volumeSize[0],bcY*volumeSize[1],bcZ*volumeSize[2]],vertexPositions[3]=[adX*volumeSize[0],adY*volumeSize[1],adZ*volumeSize[2]],vertexPositions[4]=[bcX*volumeSize[0],bcY*volumeSize[1],bcZ*volumeSize[2]],vertexPositions[5]=[acX*volumeSize[0],acY*volumeSize[1],acZ*volumeSize[2]],vertexColors[0]=[adX,adY,adZ],vertexColors[1]=[bdX,bdY,bdZ],vertexColors[2]=[bcX,bcY,bcZ],vertexColors[3]=[adX,adY,adZ],vertexColors[4]=[bcX,bcY,bcZ],vertexColors[5]=[acX,acY,acZ]),me.isVisible(0,0,-.5,0,0,-1.5,camX,camY,camZ)&&(vertexPositions[6]=[bdX*volumeSize[0],bdY*volumeSize[1],bdZ*volumeSize[2]],vertexPositions[7]=[bcX*volumeSize[0],bcY*volumeSize[1],bcZ*volumeSize[2]],vertexPositions[8]=[acX*volumeSize[0],acY*volumeSize[1],acZ*volumeSize[2]],vertexPositions[9]=[bdX*volumeSize[0],bdY*volumeSize[1],bdZ*volumeSize[2]],vertexPositions[10]=[acX*volumeSize[0],acY*volumeSize[1],acZ*volumeSize[2]],vertexPositions[11]=[adX*volumeSize[0],adY*volumeSize[1],adZ*volumeSize[2]],vertexColors[6]=[bdX,bdY,bdZ],vertexColors[7]=[bcX,bcY,bcZ],vertexColors[8]=[acX,acY,acZ],vertexColors[9]=[bdX,bdY,bdZ],vertexColors[10]=[acX,acY,acZ],vertexColors[11]=[adX,adY,adZ]),me.isVisible(0,.5,0,0,1.5,0,camX,camY,camZ)&&(vertexPositions[12]=[adX*volumeSize[0],adY*volumeSize[1],adZ*volumeSize[2]],vertexPositions[13]=[bdX*volumeSize[0],bdY*volumeSize[1],bdZ*volumeSize[2]],vertexPositions[14]=[bcX*volumeSize[0],bcY*volumeSize[1],bcZ*volumeSize[2]],vertexPositions[15]=[adX*volumeSize[0],adY*volumeSize[1],adZ*volumeSize[2]],vertexPositions[16]=[bcX*volumeSize[0],bcY*volumeSize[1],bcZ*volumeSize[2]],vertexPositions[17]=[acX*volumeSize[0],acY*volumeSize[1],acZ*volumeSize[2]],vertexColors[12]=[adX,adY,adZ],vertexColors[13]=[bdX,bdY,bdZ],vertexColors[14]=[bcX,bcY,bcZ],vertexColors[15]=[adX,adY,adZ],vertexColors[16]=[bcX,bcY,bcZ],vertexColors[17]=[acX,acY,acZ]),me.isVisible(0,-.5,0,0,-1.5,0,camX,camY,camZ)&&(vertexPositions[18]=[acX*volumeSize[0],acY*volumeSize[1],acZ*volumeSize[2]],vertexPositions[19]=[adX*volumeSize[0],adY*volumeSize[1],adZ*volumeSize[2]],vertexPositions[20]=[bdX*volumeSize[0],bdY*volumeSize[1],bdZ*volumeSize[2]],vertexPositions[21]=[acX*volumeSize[0],acY*volumeSize[1],acZ*volumeSize[2]],vertexPositions[22]=[bdX*volumeSize[0],bdY*volumeSize[1],bdZ*volumeSize[2]],vertexPositions[23]=[bcX*volumeSize[0],bcY*volumeSize[1],bcZ*volumeSize[2]],vertexColors[18]=[acX,acY,acZ],vertexColors[19]=[adX,adY,adZ],vertexColors[20]=[bdX,bdY,bdZ],vertexColors[21]=[acX,acY,acZ],vertexColors[22]=[bdX,bdY,bdZ],vertexColors[23]=[bcX,bcY,bcZ]),me.isVisible(.5,0,0,1.5,0,0,camX,camY,camZ)&&(vertexPositions[24]=[bdX*volumeSize[0],bdY*volumeSize[1],bdZ*volumeSize[2]],vertexPositions[25]=[bcX*volumeSize[0],bcY*volumeSize[1],bcZ*volumeSize[2]],vertexPositions[26]=[acX*volumeSize[0],acY*volumeSize[1],acZ*volumeSize[2]],vertexPositions[27]=[bdX*volumeSize[0],bdY*volumeSize[1],bdZ*volumeSize[2]],vertexPositions[28]=[acX*volumeSize[0],acY*volumeSize[1],acZ*volumeSize[2]],vertexPositions[29]=[adX*volumeSize[0],adY*volumeSize[1],adZ*volumeSize[2]],vertexColors[24]=[bdX,bdY,bdZ],vertexColors[25]=[bcX,bcY,bcZ],vertexColors[26]=[acX,acY,acZ],vertexColors[27]=[bdX,bdY,bdZ],vertexColors[28]=[acX,acY,acZ],vertexColors[29]=[adX,adY,adZ]),me.isVisible(-.5,0,0,-1.5,0,0,camX,camY,camZ)&&(vertexPositions[30]=[adX*volumeSize[0],adY*volumeSize[1],adZ*volumeSize[2]],vertexPositions[31]=[bdX*volumeSize[0],bdY*volumeSize[1],bdZ*volumeSize[2]],vertexPositions[32]=[bcX*volumeSize[0],bcY*volumeSize[1],bcZ*volumeSize[2]],vertexPositions[33]=[adX*volumeSize[0],adY*volumeSize[1],adZ*volumeSize[2]],vertexPositions[34]=[bcX*volumeSize[0],bcY*volumeSize[1],bcZ*volumeSize[2]],vertexPositions[35]=[acX*volumeSize[0],acY*volumeSize[1],acZ*volumeSize[2]],vertexColors[30]=[adX,adY,adZ],vertexColors[31]=[bdX,bdY,bdZ],vertexColors[32]=[bcX,bcY,bcZ],vertexColors[33]=[adX,adY,adZ],vertexColors[34]=[bcX,bcY,bcZ],vertexColors[35]=[acX,acY,acZ]);for(var positions=[],colors=[],i=0;i<vertexPositions.length;i++){var backCounter=vertexPositions.length-1-i,x=vertexPositions[backCounter][0],y=vertexPositions[backCounter][1],z=vertexPositions[backCounter][2]*zFactor,r=vertexColors[backCounter][0],g=vertexColors[backCounter][1],b=vertexColors[backCounter][2];positions.push(x),positions.push(y),positions.push(z),colors.push(r),colors.push(g),colors.push(b),colors.push(1)}var geometry=new THREE.BufferGeometry,bufferPositions=new Float32Array(positions);return geometry.addAttribute("position",new THREE.BufferAttribute(bufferPositions,3)),geometry.addAttribute("vertColor",new THREE.BufferAttribute(new Float32Array(colors),4)),geometry.computeBoundingBox(),geometry},me};var Core=function(conf){this.stats,this.isStatsOn=!1,this._isRotate=!1,this.l=conf.l,this.s=conf.s,this.hMin=conf.hMin,this.hMax=conf.hMax,this.minRefl=conf.minRefl,this.minSos=conf.minSos,this.minAtten=conf.minAtten,this.maxRefl=conf.maxRefl,this.maxSos=conf.maxSos,this.maxAtten=conf.maxAtten,this.lightRotation=0,this.zFactor=void 0!=conf.zFactor?conf.zFactor:1,this._mode=void 0==conf.mode?"3d":conf.mode,this._steps=void 0==conf.steps?20:conf.steps,this._slices_gap=void 0==typeof conf.slices_range?[0,"*"]:conf.slices_range,this._slicemap_row_col=[16,16],this._gray_value=[0,1],this._slicemaps_images=[],this._slicemaps_paths=conf.slicemaps_paths,this._slicemaps_width=[],this._slicemaps_textures=[],this._opacity_factor=void 0!=conf.opacity_factor?conf.opacity_factor:35,this._color_factor=void 0!=conf.color_factor?conf.color_factor:3,this._shader_name=void 0==conf.shader_name?"secondPassDefault":conf.shader_name,this._render_size=void 0==conf.renderer_size?["*","*"]:conf.renderer_size,this._canvas_size=conf.renderer_canvas_size,this._render_clear_color="#000",this._transfer_function_as_image=new Image,this._volume_sizes=[1024,1024,1024],this._geometry_dimensions={xmin:0,xmax:1,ymin:0,ymax:1,zmin:0,zmax:1},this._threshold_otsu_index=0,this._threshold_isodata_index=0,this._threshold_yen_index=0,this._threshold_li_index=0,this._transfer_function_colors=[{color:"#00004c",pos:0},{color:"#000054",pos:.013888888888888888},{color:"#000060",pos:.027777777777777776},{color:"#000068",pos:.041666666666666664},{color:"#000073",pos:.05555555555555555},{color:"#00007c",pos:.06944444444444445},{color:"#000087",pos:.08333333333333333},{color:"#00008f",pos:.09722222222222221},{color:"#00009a",pos:.1111111111111111},{color:"#0000a6",pos:.125},{color:"#0000ae",pos:.1388888888888889},{color:"#0000b9",pos:.15277777777777776},{color:"#0000c2",pos:.16666666666666666},{color:"#0000cd",pos:.18055555555555555},{color:"#0000d5",pos:.19444444444444442},{color:"#0000e0",pos:.20833333333333331},{color:"#0000e9",pos:.2222222222222222},{color:"#0000f4",pos:.2361111111111111},{color:"#0101ff",pos:.25},{color:"#0d0dff",pos:.2638888888888889},{color:"#1d1dff",pos:.2777777777777778},{color:"#2828ff",pos:.29166666666666663},{color:"#3939ff",pos:.3055555555555555},{color:"#4545ff",pos:.3194444444444444},{color:"#5555ff",pos:.3333333333333333},{color:"#6161ff",pos:.3472222222222222},{color:"#7171ff",pos:.3611111111111111},{color:"#8181ff",pos:.375},{color:"#8d8dff",pos:.38888888888888884},{color:"#9d9dff",pos:.40277777777777773},{color:"#a8a8ff",pos:.41666666666666663},{color:"#b9b9ff",pos:.4305555555555555},{color:"#c5c5ff",pos:.4444444444444444},{color:"#d5d5ff",pos:.4583333333333333},{color:"#e1e1ff",pos:.4722222222222222},{color:"#f1f1ff",pos:.4861111111111111},{color:"#fffdfd",pos:.5},{color:"#fff1f1",pos:.5138888888888888},{color:"#ffe1e1",pos:.5277777777777778},{color:"#ffd5d5",pos:.5416666666666666},{color:"#ffc5c5",pos:.5555555555555556},{color:"#ffb9b9",pos:.5694444444444444},{color:"#ffa9a9",pos:.5833333333333333},{color:"#ff9d9d",pos:.5972222222222222},{color:"#ff8d8d",pos:.611111111111111},{color:"#ff7d7d",pos:.625},{color:"#ff7171",pos:.6388888888888888},{color:"#ff6161",pos:.6527777777777778},{color:"#ff5555",pos:.6666666666666666},{color:"#ff4545",pos:.6805555555555555},{color:"#ff3838",pos:.6944444444444444},{color:"#ff2828",pos:.7083333333333333},{color:"#ff1d1d",pos:.7222222222222222},{color:"#ff0d0d",pos:.736111111111111},{color:"#fd0000",pos:.75},{color:"#f70000",pos:.7638888888888888},{color:"#ef0000",pos:.7777777777777777},{color:"#e90000",pos:.7916666666666666},{color:"#e10000",pos:.8055555555555555},{color:"#db0000",pos:.8194444444444444},{color:"#d30000",pos:.8333333333333333},{color:"#cd0000",pos:.8472222222222222},{color:"#c50000",pos:.861111111111111},{color:"#bd0000",pos:.875},{color:"#b70000",pos:.8888888888888888},{color:"#af0000",pos:.9027777777777777},{color:"#a90000",pos:.9166666666666666},{color:"#a10000",pos:.9305555555555555},{color:"#9b0000",pos:.9444444444444444},{color:"#930000",pos:.9583333333333333},{color:"#8d0000",pos:.9722222222222222},{color:"#850000",pos:.986111111111111}],this._dom_container_id=void 0!=conf.dom_container?conf.dom_container:"wave-container",this._dom_container={},this._render={},this._camera={},this._camera_settings={rotation:{x:0,y:0,z:0},position:{x:0,y:0,z:3}},this._rtTexture={},this._geometry={},this._geometry_settings={rotation:{x:0,y:0,z:0}},this._materialFirstPass={},this._materialSecondPass={},this._sceneFirstPass={},this._sceneSecondPass={},this._meshFirstPass={},this._meshSecondPass={},this.onPreDraw=new VRC.EventDispatcher,this.onPostDraw=new VRC.EventDispatcher,this.onResizeWindow=new VRC.EventDispatcher,this.onCameraChange=new VRC.EventDispatcher,this.onCameraChangeStart=new VRC.EventDispatcher,this.onCameraChangeEnd=new VRC.EventDispatcher,this.onChangeTransferFunction=new VRC.EventDispatcher,this._onWindowResizeFuncIndex_canvasSize=-1,this._onWindowResizeFuncIndex_renderSize=-1,this._callback=conf.callback;try{this._canvas_size[0]>this._canvas_size[1]&&(this._camera_settings.position.z=2)}catch(e){}};Core.prototype.setShaderName=function(value){this._shader_name=value,"3d"==this._mode&&(this._materialSecondPass=new THREE.ShaderMaterial({vertexShader:this._shaders[this._shader_name].vertexShader,fragmentShader:ejs.render(this._shaders[this._shader_name].fragmentShader,{maxTexturesNumber:this.getMaxTexturesNumber()}),uniforms:{uRatio:{type:"f",value:this.zFactor},uBackCoord:{type:"t",value:this._rtTexture},uSliceMaps:{type:"tv",value:this._slicemaps_textures},uLightPos:{type:"v3",value:new THREE.Vector3},uSetViewMode:{type:"i",value:0},uSteps:{type:"i",value:this._steps},uSlicemapWidth:{type:"f",value:this._slicemaps_width},uNumberOfSlices:{type:"f",value:(parseFloat(this.getSlicesRange()[1])+1)/1.000001},uSlicesOverX:{type:"f",value:this._slicemap_row_col[0]},uSlicesOverY:{type:"f",value:this._slicemap_row_col[1]},uOpacityVal:{type:"f",value:this._opacity_factor},darkness:{type:"f",value:this._color_factor},l:{type:"f",value:this.l},s:{type:"f",value:this.s},hMin:{type:"f",value:this.hMin},hMax:{type:"f",value:this.hMax},minSos:{type:"f",value:this.minSos},maxSos:{type:"f",value:this.maxSos},minAtten:{type:"f",value:this.minAtten},maxAtten:{type:"f",value:this.maxAtten},minRefl:{type:"f",value:this.minRefl},maxRefl:{type:"f",value:this.maxRefl},uTransferFunction:{type:"t",value:this._transfer_function},uColorVal:{type:"f",value:this._color_factor},uAbsorptionModeIndex:{type:"f",value:this._absorption_mode_index},uMinGrayVal:{type:"f",value:this._gray_value[0]},uMaxGrayVal:{type:"f",value:this._gray_value[1]},uIndexOfImage:{type:"f",value:this._indexOfImage},uSosThresholdBot:{type:"f",value:this._sosThresholdBot},uSosThresholdTop:{type:"f",value:this._sosThresholdTop},uAttenThresholdBot:{type:"f",value:this._attenThresholdBot},uAttenThresholdTop:{type:"f",value:this._attenThresholdTop}},side:THREE.BackSide,transparent:!0}),this._meshSecondPass=new THREE.Mesh(this._geometry,this._materialSecondPass),this._sceneSecondPass=new THREE.Scene,this._sceneSecondPass.add(this._meshSecondPass),this.addWireframe())},Core.prototype.init=function(){var me=this;if(this._container=this.getDOMContainer(),this._render=new THREE.WebGLRenderer({preserveDrawingBuffer:!0,antialias:!0,alpha:!0}),this._render.domElement.id="wave-"+this._dom_container_id,this._render.setSize(this.getRenderSizeInPixels()[0],this.getRenderSizeInPixels()[1]),this._render.setClearColor(this._render_clear_color,0),this._container.innerHTML=" ",this._container.appendChild(this._render.domElement),this._camera=new THREE.PerspectiveCamera(45,this.getRenderSizeInPixels()[0]/this.getRenderSizeInPixels()[1],.01,11),this._camera.position.x=this._camera_settings.position.x,this._camera.position.y=this._camera_settings.position.y,this._camera.position.z=this._camera_settings.position.z,this._camera.rotation.x=this._camera_settings.rotation.x,this._camera.rotation.y=this._camera_settings.rotation.y,this._camera.rotation.z=this._camera_settings.rotation.z,this.isAxisOn=!1,this._controls=new THREE.TrackballControls(this._camera,this._render.domElement),this._controls.rotateSpeed=2,this._controls.zoomSpeed=2,this._controls.panSpeed=2,this._controls.noZoom=!1,this._controls.noPan=!1,this._controls.staticMoving=!0,this._controls.dynamicDampingFactor=.3,this._controls.autoRotate=!0,this._rtTexture=new THREE.WebGLRenderTarget(this.getRenderSizeInPixels()[0],this.getRenderSizeInPixels()[1],{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping,format:THREE.RGBFormat,type:THREE.UnsignedByteType,generateMipmaps:!1}),"2d"==this._mode){this._tex1=THREE.ImageUtils.loadTexture(this._slicemaps_paths[0]),this._tex1.minFilter=THREE.LinearFilter,this._tex2=THREE.ImageUtils.loadTexture(this._slicemaps_paths[1]),this._tex2.minFilter=THREE.LinearFilter,this._cm=THREE.ImageUtils.loadTexture("http://katrin.kit.edu/static/colormaps/cm_BrBG.png"),this._cm.minFilter=THREE.LinearFilter,this._material2D=new THREE.ShaderMaterial({vertexShader:this._shaders.secondPass2DCustom.vertexShader,fragmentShader:ejs.render(this._shaders.secondPass2DCustom.fragmentShader,{maxTexturesNumber:this.getMaxTexturesNumber()}),uniforms:{uSetViewMode:{type:"i",value:0},texture1:{type:"t",value:this._tex1},texture2:{type:"t",value:this._tex2},colourmap:{type:"t",value:this._cm},uZoom:{type:"v4",value:new THREE.Vector4(0,1,0,1)},resolution:{type:"v2",value:new THREE.Vector2(this._render_size[0],this._render_size[1])}}});var geometry=new THREE.PlaneBufferGeometry(10,10);this._meshFirstPass=new THREE.Mesh(geometry,this._material2D),this._sceneFirstPass=new THREE.Scene,this._sceneFirstPass.add(this._meshFirstPass)}else{this._materialFirstPass=new THREE.ShaderMaterial({vertexShader:this._shaders.firstPass.vertexShader,fragmentShader:this._shaders.firstPass.fragmentShader,side:THREE.FrontSide,transparent:!0}),this._materialSecondPass=new THREE.ShaderMaterial({vertexShader:this._shaders[this._shader_name].vertexShader,fragmentShader:ejs.render(this._shaders[this._shader_name].fragmentShader,{maxTexturesNumber:me.getMaxTexturesNumber()}),uniforms:{uRatio:{type:"f",value:this.zFactor},uBackCoord:{type:"t",value:this._rtTexture},uSliceMaps:{type:"tv",value:this._slicemaps_textures},uLightPos:{type:"v3",value:new THREE.Vector3},uSetViewMode:{type:"i",value:0},uSteps:{type:"i",value:this._steps},uSlicemapWidth:{type:"f",value:this._slicemaps_width},uNumberOfSlices:{type:"f",value:(parseFloat(this.getSlicesRange()[1])+1)/1.000001},uSlicesOverX:{type:"f",value:this._slicemap_row_col[0]},uSlicesOverY:{type:"f",value:this._slicemap_row_col[1]},uOpacityVal:{type:"f",value:this._opacity_factor},darkness:{type:"f",value:this._color_factor},l:{type:"f",value:this.l},s:{type:"f",value:this.s},hMin:{type:"f",value:this.hMin},hMax:{type:"f",value:this.hMax},minSos:{type:"f",value:this.minSos},maxSos:{type:"f",value:this.maxSos},minAtten:{type:"f",value:this.minAtten},maxAtten:{type:"f",value:this.maxAtten},minRefl:{type:"f",value:this.minRefl},maxRefl:{type:"f",value:this.maxRefl},uTransferFunction:{type:"t",value:this._transfer_function},uColorVal:{type:"f",value:this._color_factor},uAbsorptionModeIndex:{type:"f",value:this._absorption_mode_index},uMinGrayVal:{type:"f",value:this._gray_value[0]},uMaxGrayVal:{type:"f",value:this._gray_value[1]},uIndexOfImage:{type:"f",value:this._indexOfImage},uSosThresholdBot:{type:"f",value:this._sosThresholdBot},uSosThresholdTop:{type:"f",value:this._sosThresholdTop},uAttenThresholdBot:{type:"f",value:this._attenThresholdBot},uAttenThresholdTop:{type:"f",value:this._attenThresholdTop}},side:THREE.BackSide,transparent:!0}),this._sceneFirstPass=new THREE.Scene,this._sceneSecondPass=new THREE.Scene,this._initGeometry(this.getGeometryDimensions(),this.getVolumeSizeNormalized()),this._meshFirstPass=new THREE.Mesh(this._geometry,this._materialFirstPass),this._meshSecondPass=new THREE.Mesh(this._geometry,this._materialSecondPass),this._sceneFirstPass.add(this._meshFirstPass),this._sceneSecondPass.add(this._meshSecondPass);var mesh=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshNormalMaterial);this._wireframe=new THREE.BoxHelper(mesh),this._wireframe.material.color.set(14935011),this._sceneSecondPass.add(this._wireframe);var sphere=new THREE.SphereGeometry(.1);this._light1=new THREE.PointLight(16711744,2,50),this._light1.add(new THREE.Mesh(sphere,new THREE.MeshBasicMaterial({color:16711744}))),this._light1.position.set(1,0,0),this._parent=new THREE.Object3D,this._sceneSecondPass.add(this._parent),this._pivot=new THREE.Object3D,this._parent.add(this._pivot)}"3d"==this._mode&&this.setTransferFunctionByColors(this._transfer_function_colors),this.setGeometryDimensions(this.getGeometryDimensions());var update=function(){1==me.isStatsOn&&(me.stats.begin(),me.stats.end()),requestAnimationFrame(update)};requestAnimationFrame(update),window.addEventListener("resize",function(){console.log("resize"),me.onResizeWindow.call()},!1),this._controls.addEventListener("change",function(){console.log("Controls Changes1"),me.onCameraChange.call()}),this._controls.addEventListener("scroll",function(){console.log("Controls Changes Scroll"),me.onCameraChange.call()}),this._controls.addEventListener("start",function(){console.log("Controls Starts"),me.onCameraChangeStart.call()}),this._controls.addEventListener("end",function(){console.log("Controls End"),me.onCameraChangeEnd.call()}),this._onWindowResizeFuncIndex_canvasSize=this.onResizeWindow.add(function(){me.setRenderCanvasSize("*","*")},!1),this._render.setSize(this.getRenderSizeInPixels()[0],this.getRenderSizeInPixels()[1]),this.setRenderCanvasSize(this.getCanvasSize()[0],this.getCanvasSize()[1]);try{this._callback()}catch(e){}},Core.prototype._secondPassSetUniformValue=function(key,value){this._materialSecondPass.uniforms[key].value=value},Core.prototype._setSlicemapsTextures=function(images){for(var textures=[],i=0;i<images.length;i++){var texture=new THREE.Texture(images[i]);texture.magFilter=THREE.LinearFilter,texture.minFilter=THREE.LinearFilter,texture.wrapS=texture.wrapT=THREE.ClampToEdgeWrapping,texture.generateMipmaps=!1,texture.flipY=!1,texture.needsUpdate=!0,textures.push(texture)}this._slicemaps_textures=textures},Core.prototype.setTransferFunctionByImage=function(image){console.log("Core: setTransferFunctionByImage()"),this._transfer_function_as_image=image;var texture=new THREE.Texture(image);texture.magFilter=THREE.LinearFilter,texture.minFilter=THREE.LinearFilter,texture.wrapS=texture.wrapT=THREE.ClampToEdgeWrapping,texture.generateMipmaps=!1,texture.flipY=!0,texture.needsUpdate=!0,"3d"==this._mode&&this._secondPassSetUniformValue("uTransferFunction",texture),this.onChangeTransferFunction.call(image)},Core.prototype.setTransferFunctionByColors=function(colors){console.log("Core: setTransferFunctionByColors()"),this._transfer_function_colors=colors;var canvas=document.createElement("canvas");canvas.width=512,canvas.height=2;for(var ctx=canvas.getContext("2d"),grd=ctx.createLinearGradient(0,0,canvas.width-1,canvas.height-1),i=0;i<colors.length;i++)grd.addColorStop(colors[i].pos,colors[i].color);ctx.fillStyle=grd,ctx.fillRect(0,0,canvas.width,canvas.height);var image=new Image;image.src=canvas.toDataURL(),image.style.width="20 px",image.style.height="512 px";this.setTransferFunctionByImage(image);this.onChangeTransferFunction.call(image)},Core.prototype.getTransferFunctionAsImage=function(){return this._transfer_function_as_image},Core.prototype.getBase64=function(){return this._render.domElement.toDataURL("image/jpeg")},Core.prototype._initGeometry=function(geometryDimensions,volumeSizes){var geometryHelper=new VRC.GeometryHelper;this._geometry=geometryHelper.createBoxGeometry1(geometryDimensions,volumeSizes,this.zFactor),this._geometry.applyMatrix((new THREE.Matrix4).makeTranslation(-volumeSizes[0]/2,-volumeSizes[1]/2,-volumeSizes[2]/2)),this._geometry.doubleSided=!0},Core.prototype.setMode=function(conf){this._shader_name=conf.shader_name,"3d"==this._mode&&(this._materialSecondPass=new THREE.ShaderMaterial({vertexShader:this._shaders[this._shader_name].vertexShader,fragmentShader:ejs.render(this._shaders[this._shader_name].fragmentShader,{maxTexturesNumber:this.getMaxTexturesNumber()}),attributes:{vertColor:{type:"c",value:[]}},uniforms:{uRatio:{type:"f",value:this.zFactor},uBackCoord:{type:"t",value:this._rtTexture},uSliceMaps:{type:"tv",value:this._slicemaps_textures},uLightPos:{type:"v3",value:new THREE.Vector3},uSetViewMode:{type:"i",value:0},uNumberOfSlices:{type:"f",value:(parseFloat(this.getSlicesRange()[1])+1)/1.000001},uSlicemapWidth:{type:"f",value:this._slicemaps_width},uSlicesOverX:{type:"f",value:this._slicemap_row_col[0]},uSlicesOverY:{type:"f",value:this._slicemap_row_col[1]},uOpacityVal:{type:"f",value:this._opacity_factor},darkness:{type:"f",value:this._color_factor},l:{type:"f",value:this.l},s:{type:"f",value:this.s},hMin:{type:"f",value:this.hMin},hMax:{type:"f",value:this.hMax},minSos:{type:"f",value:this.minSos},maxSos:{type:"f",value:this.maxSos},minAtten:{type:"f",value:this.minAtten},maxAtten:{type:"f",value:this.maxAtten},minRefl:{type:"f",value:this.minRefl},maxRefl:{type:"f",value:this.maxRefl}},side:THREE.BackSide,transparent:!0}),this._meshSecondPass=new THREE.Mesh(this._geometry,this._materialSecondPass),this._sceneSecondPass=new THREE.Scene,this._sceneSecondPass.add(this._meshSecondPass))},Core.prototype.setZoom=function(x1,x2,y1,y2){console.log("apply Zooming."),this._material2D.uniforms.uZoom.value=new THREE.Vector4(x1,x2,y1,y2)},Core.prototype.set2DTexture=function(urls){console.log("apply new Textures");var chosen_cm=THREE.ImageUtils.loadTexture(urls[0]),chosen_cm2=THREE.ImageUtils.loadTexture(urls[1]);chosen_cm.minFilter=THREE.NearestFilter,chosen_cm2.minFilter=THREE.NearestFilter,this._material2D.uniforms.texture1.value=chosen_cm,this._material2D.uniforms.texture2.value=chosen_cm2,this._material2D.needsUpdate=!0},Core.prototype.setShader=function(codeblock){var final_code="uniform vec2 resolution;     precision mediump int;     precision mediump float;     varying vec4 pos;     uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];     uniform sampler2D texture1;     uniform sampler2D texture2;     uniform sampler2D colourmap;     uniform vec4 uZoom;     void main(void) {     vec2 pos = gl_FragCoord.xy / resolution.xy;     float b1, b2, b3, b4, b5, b6;     vec3 t1, t2;     float newX = ((uZoom.y - uZoom.x)  * pos.x) + uZoom.x;     float newY = ((uZoom.w - uZoom.z)  * pos.y) + uZoom.z;     t1 = texture2D(texture1, vec2(newX, newY)).xyz;     t2 = texture2D(texture2, vec2(newX, newY)).xyz;     b1 = t1.x;     b2 = t1.y;     b3 = t1.z;     b4 = t2.x;     b5 = t2.y;     b6 = t2.z;"+codeblock+"}";this._sceneFirstPass.remove(this._meshFirstPass),this._material2D=new THREE.ShaderMaterial({vertexShader:this._shaders.secondPass2DCustom.vertexShader,fragmentShader:ejs.render(final_code,{maxTexturesNumber:this.getMaxTexturesNumber()}),uniforms:{uSetViewMode:{type:"i",value:0},texture1:{type:"t",value:this._tex1},texture2:{type:"t",value:this._tex2},colourmap:{type:"t",value:this._cm},uZoom:{type:"v4",value:new THREE.Vector4(0,1,0,1)},resolution:{type:"v2",value:new THREE.Vector2(this._render_size[0],this._render_size[1])}}});var geometry=new THREE.PlaneBufferGeometry(10,10);this._meshFirstPass=new THREE.Mesh(geometry,this._material2D),this._sceneFirstPass=new THREE.Scene,this._sceneFirstPass.add(this._meshFirstPass)},Core.prototype.calcXZ=function(xa,ya,za,xb,yb,zb){tempxa=xa,tempya=ya,tempza=za,f=15,xb=xa/f,yb=ya/f,zb=za/f,console.log("Xb = ",xa.toFixed(2)),console.log("Yb = ",ya.toFixed(2)),console.log("Zb = ",za.toFixed(2)),r=.5,k=(xa-xb)/(za-zb),k1=k*xb+zb,p=Math.pow(k,2)+1,n=2*zb*k-2*xb-2*k*k1,m=Math.pow(xb,2)-2*zb*k1+Math.pow(zb,2)+Math.pow(k1,2)-Math.pow(r,2),za<=zb?(xf1=(-1*n+Math.sqrt(Math.pow(n,2)-4*p*m))/(2*p),zf1=k1-k*xf1,xf2=(-1*n-Math.sqrt(Math.pow(n,2)-4*p*m))/(2*p),zf2=k1-k*xf2):(xf1=(-1*n-Math.sqrt(Math.pow(n,2)-4*p*m))/(2*p),zf1=k1-k*xf1,xf2=(-1*n+Math.sqrt(Math.pow(n,2)-4*p*m))/(2*p),zf2=k1-k*xf2),yf1=yb,yf2=yb,console.log(""),xn=ya*zf1-za*yf1,yn=za*xf1-xa*zf1,zn=xa*yf1-ya*xf1,k1=.5,k2=.5,lengthH=Math.sqrt(Math.pow(xn,2)+Math.pow(yn,2)+Math.pow(zn,2)),xn2=xn*(1/lengthH)*k1+k2,yn2=yn*(1/lengthH)*k1+k2,zn2=zn*(1/lengthH)*k1+k2,xn1=(za*yf1-ya*zf1)*(1/lengthH)*k1+k2,yn1=(xa*zf1-za*xf1)*(1/lengthH)*k1+k2,zn1=(ya*xf1-xa*yf1)*(1/lengthH)*k1+k2,this._setGeometry1(this._geometry_dimensions,this.getVolumeSizeNormalized(),xf1,yf1,zf1,xf2,yf2,zf2,xn1,yn1,zn1,xn2,yn2,zn2,tempxa,tempya,tempza)},Core.prototype._setGeometry=function(geometryDimensions,volumeSizes){var geometry=(new VRC.GeometryHelper).createBoxGeometry(geometryDimensions,volumeSizes,1),colorArray=geometry.attributes.vertColor.array,positionArray=geometry.attributes.position.array;this._geometry.attributes.vertColor.array=colorArray,this._geometry.attributes.vertColor.needsUpdate=!0,this._geometry.attributes.position.array=positionArray,this._geometry.attributes.position.needsUpdate=!0,this._geometry.applyMatrix((new THREE.Matrix4).makeTranslation(-volumeSizes[0]/2,-volumeSizes[1]/2,-volumeSizes[2]/2)),this._geometry.doubleSided=!0},Core.prototype._setGeometry1=function(geometryDimensions,volumeSizes,aX,aY,aZ,bX,bY,bZ,xn1,yn1,zn1,xn2,yn2,zn2,camX,camY,camZ){var geometry=(new VRC.GeometryHelper).createBoxGeometry1(geometryDimensions,volumeSizes,1,aX,aY,aZ,bX,bY,bZ,xn1,yn1,zn1,xn2,yn2,zn2,camX,camY,camZ),colorArray=geometry.attributes.vertColor.array,positionArray=geometry.attributes.position.array;this._geometry.attributes.vertColor.array=colorArray,this._geometry.attributes.vertColor.needsUpdate=!0,this._geometry.attributes.position.array=positionArray,this._geometry.attributes.position.needsUpdate=!0,this._geometry.applyMatrix((new THREE.Matrix4).makeTranslation(-volumeSizes[0]/2,-volumeSizes[1]/2,-volumeSizes[2]/2)),this._geometry.doubleSided=!0},Core.prototype.setSlicemapsImages=function(images,imagesPaths){console.log("Core: setSlicemapsImages()"),this._slicemaps_images=images,this._slicemaps_paths=void 0!=imagesPaths?imagesPaths:this._slicemaps_paths,this._setSlicemapsTextures(images),"3d"==this._mode&&this._secondPassSetUniformValue("uSliceMaps",this._slicemaps_textures),this._slicemaps_width=images[0].width,"3d"==this._mode&&this._secondPassSetUniformValue("uSlicemapWidth",this._slicemaps_width)},Core.prototype.setSteps=function(steps){this._steps=steps,"3d"==this._mode&&this._secondPassSetUniformValue("uSteps",this._steps)},Core.prototype.setSlicesRange=function(from,to){console.log("Core: setSlicesRange()"),this._slices_gap=[from,to],"3d"==this._mode&&this._secondPassSetUniformValue("uNumberOfSlices",(parseFloat(this.getSlicesRange()[1])+1)/1.000001)},Core.prototype.setOpacityFactor=function(opacity_factor){console.log("Core: setOpacityFactor()"),this._opacity_factor=opacity_factor,"3d"==this._mode&&this._secondPassSetUniformValue("uOpacityVal",this._opacity_factor)},Core.prototype.setColorFactor=function(color_factor){console.log("Core: setColorFactor()"),this._color_factor=color_factor,"3d"==this._mode&&this._secondPassSetUniformValue("darkness",this._color_factor)},Core.prototype.setAbsorptionMode=function(mode_index){console.log("Core: setAbsorptionMode()"),this._absorption_mode_index=mode_index,"3d"==this._mode&&this._secondPassSetUniformValue("uAbsorptionModeIndex",this._absorption_mode_index)},Core.prototype.setIndexOfImage=function(indexOfImage){console.log("Core: setIndexOfImage()"),this._indexOfImage=indexOfImage,"3d"==this._mode&&this._secondPassSetUniformValue("uIndexOfImage",this._indexOfImage)},Core.prototype.setVolumeSize=function(width,height,depth){console.log("Core: setVolumeSize()"),this._volume_sizes=[width,height,depth];var maxSize=Math.max(this.getVolumeSize()[0],this.getVolumeSize()[1],this.getVolumeSize()[2]),normalizedVolumeSizes=[this.getVolumeSize()[0]/maxSize,this.getVolumeSize()[1]/maxSize,this.getVolumeSize()[2]/maxSize];this._setGeometry(this.getGeometryDimensions(),normalizedVolumeSizes)},Core.prototype.setGeometryDimensions=function(geometryDimension){console.log("Core: setGeometryDimension()"),this._geometry_dimensions=geometryDimension,this._setGeometry(this._geometry_dimensions,this.getVolumeSizeNormalized())},Core.prototype.setRenderCanvasSize=function(width,height){console.log("Core: setRenderCanvasSize()"),this._canvas_size=[width,height],"*"!=this._canvas_size[0]&&"*"!=this._canvas_size[1]||this.onResizeWindow.isStart(this._onWindowResizeFuncIndex_canvasSize)||this.onResizeWindow.start(this._onWindowResizeFuncIndex_canvasSize),"*"==this._canvas_size[0]&&"*"==this._canvas_size[1]||!this.onResizeWindow.isStart(this._onWindowResizeFuncIndex_canvasSize)||this.onResizeWindow.stop(this._onWindowResizeFuncIndex_canvasSize);var width=this.getCanvasSizeInPixels()[0],height=this.getCanvasSizeInPixels()[1];this._render.domElement.style.width=width+"px",this._render.domElement.style.height=height+"px",this._camera.aspect=width/height,this._camera.updateProjectionMatrix()},Core.prototype.setBackgroundColor=function(color){console.log("Core: setBackgroundColor()"),this._render_clear_color=color,this._render.setClearColor(color)},Core.prototype.setRowCol=function(row,col){console.log("Core: setRowCol()"),this._slicemap_row_col=[row,col],"3d"==this._mode&&(this._secondPassSetUniformValue("uSlicesOverX",this._slicemap_row_col[0]),this._secondPassSetUniformValue("uSlicesOverY",this._slicemap_row_col[1]))},Core.prototype.setGrayMinValue=function(value){console.log("Core: setMinGrayValue()"),this._gray_value[0]=value,"3d"==this._mode&&this._secondPassSetUniformValue("uMinGrayVal",this._gray_value[0])},Core.prototype.setMinSos=function(value){console.log("Core: setMinSos()"),this._gray_value[0]=value,"3d"==this._mode&&this._secondPassSetUniformValue("uMinGrayVal",this._gray_value[0])},Core.prototype.applyThresholding=function(threshold_name){switch(console.log("Core: applyThresholding()"),threshold_name){case"otsu":this.setGrayMinValue(this._threshold_otsu_index);break;case"isodata":this.setGrayMinValue(this._threshold_isodata_index);break;case"yen":this.setGrayMinValue(this._threshold_yen_index);break;case"li":this.setGrayMinValue(this._threshold_li_index)}},Core.prototype.setThresholdIndexes=function(otsu,isodata,yen,li){console.log("Core: setThresholdIndexes()"),this._threshold_otsu_index=otsu,this._threshold_isodata_index=isodata,this._threshold_yen_index=yen,this._threshold_li_index=li},Core.prototype.setGrayMaxValue=function(value){console.log("Core: setMaxGrayValue()"),this._gray_value[1]=value,"3d"==this._mode&&this._secondPassSetUniformValue("uMaxGrayVal",this._gray_value[1])},Core.prototype.setSosThresholdBot=function(sosThresholdBot){console.log("Core: setSosThresholdBot()"),this._sosThresholdBot=sosThresholdBot,"3d"==this._mode&&this._secondPassSetUniformValue("uSosThresholdBot",this._sosThresholdBot)},Core.prototype.setSosThresholdTop=function(sosThresholdTop){console.log("Core: setSosThresholdTop()"),this._sosThresholdTop=sosThresholdTop,"3d"==this._mode&&this._secondPassSetUniformValue("uSosThresholdTop",this._sosThresholdTop)},Core.prototype.setAttenThresholdBot=function(attenThresholdBot){console.log("Core: setAttenThresholdBot()"),this._attenThresholdBot=attenThresholdBot,"3d"==this._mode&&this._secondPassSetUniformValue("uAttenThresholdBot",this._attenThresholdBot)},Core.prototype.setAttenThresholdTop=function(attenThresholdTop){console.log("Core: setAttenThresholdTop()"),this._attenThresholdTop=attenThresholdTop,"3d"==this._mode&&this._secondPassSetUniformValue("uAttenThresholdTop",this._attenThresholdTop)},Core.prototype.startRotate=function(){console.log("Core: startRotate()"),this._isRotate=!0},Core.prototype.stopRotate=function(){console.log("Core: stopRotate()"),this._isRotate=!1},Core.prototype.addWireframe=function(){console.log("Core: addFrame()"),this._sceneSecondPass.add(this._wireframe),"3d"==this._mode&&(this._render.render(this._sceneFirstPass,this._camera,this._rtTexture,!0),this._render.render(this._sceneFirstPass,this._camera)),this._render.render(this._sceneSecondPass,this._camera)},Core.prototype.removeWireframe=function(){console.log("Core: removeFrame()"),this._sceneSecondPass.remove(this._wireframe),"3d"==this._mode&&(this._render.render(this._sceneFirstPass,this._camera,this._rtTexture,!0),this._render.render(this._sceneFirstPass,this._camera)),this._render.render(this._sceneSecondPass,this._camera)},Core.prototype.setStats=function(value){console.log("Core: setStats()"),console.log("Enable Stats: "+this.isStatsOn),1==value?(this.isStatsOn=!0,this.stats=new Stats,this.stats.setMode(0),this.stats.domElement.style.position="absolute",this.stats.domElement.style.right="10px",this.stats.domElement.style.top="10px",document.body.appendChild(this.stats.domElement)):document.getElementById("stats").remove()},Core.prototype.setAxis=function(value){console.log("Core: setAxis()"),console.log("Axis status: "+this.isAxisOn),this.isAxisOn?(this._sceneSecondPass.remove(this._axes),this.isAxisOn=!1):(this._sceneSecondPass.add(this._axes),this.isAxisOn=!0),"3d"==this._mode&&(this._render.render(this._sceneFirstPass,this._camera,this._rtTexture,!0),this._render.render(this._sceneFirstPass,this._camera)),this._render.render(this._sceneSecondPass,this._camera)},Core.prototype.showISO=function(){"3d"==this._mode&&(this._secondPassSetUniformValue("uSetViewMode",1),this._pivot.add(this._light1),this._render.render(this._sceneSecondPass,this._camera))},Core.prototype.showLight=function(){this._pivot.add(this._light1),this._render.render(this._sceneSecondPass,this._camera)},Core.prototype.hideLight=function(){this._pivot.remove(this._light1),this._render.render(this._sceneSecondPass,this._camera)},Core.prototype.showVolren=function(){"3d"==this._mode&&(this._secondPassSetUniformValue("uSetViewMode",0),this._pivot.remove(this._light1),this._render.render(this._sceneSecondPass,this._camera))},Core.prototype.startLightRotation=function(){this.lightRotation=1,this.draw(0)},Core.prototype.stopLightRotation=function(){this.lightRotation=0,this.draw(0)},rotSpeed=.01,Core.prototype.draw=function(fps){if(this.onPreDraw.call(fps.toFixed(3)),this.lightRotation>0&&(this._pivot.rotation.y+=.01),"3d"==this._mode){var cameraPosition=this._light1.getWorldPosition();this._secondPassSetUniformValue("uLightPos",cameraPosition)}if(this._controls.update(),this._isRotate){this._camera.position.x,this._camera.position.y,this._camera.position.z;this._camera.lookAt(this._sceneFirstPass.position),console.log(""),console.log("camX = ",this._camera.position.x.toFixed(2)),console.log("camY = ",this._camera.position.y.toFixed(2)),console.log("camZ = ",this._camera.position.z.toFixed(2)),this.calcXZ(this._camera.position.x,this._camera.position.y,this._camera.position.z,0,0,0),console.log("")}this._render.render(this._sceneFirstPass,this._camera,this._rtTexture,!0),this._render.render(this._sceneFirstPass,this._camera),"3d"==this._mode&&this._render.render(this._sceneSecondPass,this._camera),this.onPostDraw.call(fps.toFixed(3))},Core.prototype.getDOMContainer=function(){return document.getElementById(this._dom_container_id)},Core.prototype.getRenderSize=function(){return[this._render_size[0],this._render_size[1]]},Core.prototype.getRenderSizeInPixels=function(){var width=this.getRenderSize()[0],height=this.getRenderSize()[0];return"*"==this._render_size[0]&&(width=this.getCanvasSizeInPixels()[0]),"*"==this._render_size[1]&&(height=this.getCanvasSizeInPixels()[1]),[width,height]},Core.prototype.getCanvasSize=function(){return[this._canvas_size[0],this._canvas_size[1]]},Core.prototype.getCanvasSizeInPixels=function(){var width=this.getCanvasSize()[0],height=this.getCanvasSize()[1],canvas_id="#"+this._dom_container_id+" > canvas",container=document.getElementById(this._dom_container_id);return"*"==this._canvas_size[0]?(width=document.querySelector(canvas_id).width,container.style.width=width+"px"):"fullscreen"==this._canvas_size[0]&&(width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,container.style.width=width+"px"),"*"==this._canvas_size[1]?(height=document.querySelector(canvas_id).height,container.style.height=height+"px"):"fullscreen"==this._canvas_size[1]&&(height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight,container.style.height=height+"px"),[width,height]},Core.prototype.getSteps=function(){return this._steps},Core.prototype.getSlicemapsImages=function(){return this._slicemaps_images},Core.prototype.getSlicemapsPaths=function(){return this._slicemaps_paths},Core.prototype.getRowCol=function(){return this._slicemap_row_col},Core.prototype.getSlicesRange=function(){var from=this._slices_gap[0],to=this._slices_gap[1];return"*"==this._slices_gap[1]&&(to=this.getRowCol()[0]*this.getRowCol()[1]*this.getSlicemapsImages().length-1),[from,to]},Core.prototype.getVolumeSize=function(){return this._volume_sizes},Core.prototype.getMaxStepsNumber=function(){return Math.min(this.getVolumeSize()[0],this.getVolumeSize()[1])},Core.prototype.getVolumeSizeNormalized=function(){var maxSize=Math.max(this.getVolumeSize()[0],this.getVolumeSize()[1],this.getVolumeSize()[2]),normalizedVolumeSizes=[parseFloat(this.getVolumeSize()[0])/parseFloat(maxSize),parseFloat(this.getVolumeSize()[1])/parseFloat(maxSize),parseFloat(this.getVolumeSize()[2])/parseFloat(maxSize)];return console.log("Check normalized SIZE"),console.log(normalizedVolumeSizes),normalizedVolumeSizes},Core.prototype.getGeometryDimensions=function(){return this._geometry_dimensions},Core.prototype.getGrayMinValue=function(){return this._gray_value[0]},Core.prototype.getGrayMaxValue=function(){return this._gray_value[1]},Core.prototype.getClearColor=function(){return this._render_clear_color},Core.prototype.getTransferFunctionColors=function(){return this._transfer_function_colors},Core.prototype.getOpacityFactor=function(){return this._opacity_factor},Core.prototype.getColorFactor=function(){return this._color_factor},Core.prototype.getAbsorptionMode=function(){return this._absorption_mode_index},Core.prototype.getClearColor=function(){return this._render_clear_color},Core.prototype.getDomContainerId=function(){return this._dom_container_id},Core.prototype.getMaxTexturesNumber=function(){var gl=this._render.getContext();return gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)-6},Core.prototype.getMaxTextureSize=function(){var gl=this._render.getContext();return gl.getParameter(gl.MAX_TEXTURE_SIZE)},Core.prototype.getMaxFramebuferSize=function(){var gl=this._render.getContext();return gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)},Core.prototype._shaders={},window.VRC.Core=Core,window.VRC.Core.prototype._shaders.firstPass={uniforms:THREE.UniformsUtils.merge([{}]),vertexShader:["varying vec3 worldSpaceCoords;","void main()","{","    //Set the world space coordinates of the back faces vertices as output.","    worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]","    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}  "].join("\n"),fragmentShader:["varying vec3 worldSpaceCoords;","void main() {","    //The fragment's world space coordinates as fragment output.","    gl_FragColor = vec4( worldSpaceCoords.x , worldSpaceCoords.y, worldSpaceCoords.z, 1 );","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassBilinearRGB={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uSlicemapWidth:{type:"f",value:-1},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uAbsorptionModeIndex:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},uSteps:{type:"f",value:-1},uRatio:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["varying vec3 worldSpaceCoords;","varying vec4 projectedCoords;"," ","void main()","{","    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;","    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#ifdef GL_FRAGMENT_PRECISION_HIGH "," // highp is supported "," precision highp int; "," precision highp float; ","#else "," // high is not supported "," precision mediump int; "," precision mediump float; ","#endif ","// Passed from vertex","varying vec3 worldSpaceCoords; ","varying vec4 projectedCoords; ","// Passed from core","uniform sampler2D uBackCoord; ","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uSlicemapWidth;","// Assuming a bounding box of 512x512x512","// ceil( sqrt(3) * 512 ) = 887","const int MAX_STEPS = 887;","// Application specific parameters","uniform float uNumberOfSlices; ","uniform float uMinGrayVal; ","uniform float uMaxGrayVal;","uniform float uOpacityVal; ","uniform float uColorVal; ","uniform float uAbsorptionModeIndex;","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float uSteps;","uniform float uRatio;","// uniform int uAvailable_textures_number;","vec4 getVolumeValue(vec3 volpos)","{","    //if (volpos.z < 0.5)","    //    return vec4(0.0);","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    float dx2, dy2; ","    // float value; ","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float delta = 1.0 / (sliceSizeX * uRatio);","    ","    float adapted_x, adapted_y, adapted_z;","    //adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;","    //adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;","    //adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);","    ","    adapted_x = volpos.x;","    adapted_y = volpos.y;","    //adapted_z = volpos.z;","    adapted_z = 1.0 - (volpos.z * (1.0/uRatio));","    s1Original = floor(adapted_z * uNumberOfSlices);","    s2Original = s1Original + delta;","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    int tex2Index = int(floor(s2Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    s2 = mod(s2Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    ","    dx2 = fract(s2/uSlicesOverX);","    dy2 = floor(s2/uSlicesOverY)/uSlicesOverY;","    ","    texpos1.x = dx1+(adapted_x*sliceSizeX)/uSlicemapWidth;","    texpos1.y = dy1+(adapted_y*sliceSizeY)/uSlicemapWidth;","    ","    texpos2.x = dx2+(adapted_x*sliceSizeX)/uSlicemapWidth;","    texpos2.y = dy2+(adapted_y*sliceSizeY)/uSlicemapWidth;"," "," ","    vec4 value1, value2;","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","        if( tex2Index == <%=i%> )","        {","            value2 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","    <% } %>","    ","    //return vec4( (value1 + value2) * 0.5);","    ","    ","    return mix(value1, value2, fract(volpos.z* uNumberOfSlices));","}","void main(void) {"," ","    //Transform the coordinates it from [-1;1] to [0;1]","    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,","                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);","    //The back position is the world space position stored in the texture.","    vec3 backPos = texture2D(uBackCoord, texc).xyz;","                ","    //The front position is the world space position of the second render pass.","    vec3 frontPos = worldSpaceCoords;"," ","    //The direction from the front position to back position.","    vec3 dir = backPos - frontPos;","    float rayLength = length(dir);","    //Calculate how long to increment in each step.","    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;","    //float steps = 256.0;","    float delta = 1.0 / steps;","    ","    //The increment in each direction for each step.","    vec3 deltaDirection = normalize(dir) * delta;","    ","    vec3 Step = dir / steps;","    ","    float deltaDirectionLength = length(deltaDirection);","    //vec4 vpos = frontColor;  // currentPosition","    //vec3 Step = dir/uStepsF; // steps","    //Start the ray casting from the front position.","    vec3 currentPosition = frontPos;","    //The color accumulator.","    vec4 accumulatedColor = vec4(0.0);","    //The alpha value accumulated so far.","    float accumulatedAlpha = 0.0;","    ","    //How long has the ray travelled so far.","    float accumulatedLength = 0.0;","    ","    //If we have twice as many samples, we only need ~1/2 the alpha per sample.","    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.","    float alphaScaleFactor = 28.8 * delta;","    ","    vec4 colorSample = vec4(0.0);","    vec4 sample = vec4(0.0); ","    vec4 grayValue;","    float alphaSample;","    float alphaCorrection = 1.0;","    ","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float sm_delta = 1.0 / sliceSizeX;","    ","    //Perform the ray marching iterations","    for(int i = 0; i < MAX_STEPS; i++) {       ","        if(currentPosition.x > 1.0 ||","           currentPosition.y > 1.0 ||","           currentPosition.z > 1.0 ||","           currentPosition.x < 0.0 ||","           currentPosition.y < 0.0 ||","           currentPosition.z < 0.0)","            break;","        if(accumulatedColor.a>=1.0) ","            break;","        grayValue = getVolumeValue(currentPosition); ","        if(grayValue.z < 0.05 || ","           grayValue.x <= 0.0 ||","           grayValue.x >= 1.0)  ","            accumulatedColor = vec4(0.0);     ","        else { ","            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;","            colorSample.xyz = grayValue.xyz;","            //colorSample.w = alphaScaleFactor;","            colorSample.w = 0.1;","              ","            //sample.a = colorSample.a * 40.0 * (1.0 / steps);","            sample.a = colorSample.a;","            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xyz * sample.a; ","             ","            accumulatedColor += sample; ","        }    ","   ","        //Advance the ray.","        //currentPosition.xyz += deltaDirection;","        currentPosition.xyz += Step;","   ","         ","    } ","    gl_FragColor = accumulatedColor;","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassFusion={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int;","precision mediump float;","varying vec4 frontColor;","varying vec4 pos;","uniform sampler2D uBackCoord;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices;","uniform float uOpacityVal;","uniform float uSlicesOverX;","uniform float uSlicesOverY;","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l;","uniform float s;","uniform float hMin;","uniform float hMax;","//Acts like a texture3D using Z slices and trilinear filtering.","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2;","    float dx1, dy1;","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    s1Original = floor(volpos.z*uNumberOfSlices);","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0);","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","}","// x - R, y - G, z - B","// x - H, y - S, z - V","vec3 hsv2rgb(vec3 hsv)","{","    float     hue, p, q, t, ff;","    int        i;","    hsv.z = (darkness - hsv.z) * l;","    hsv.x = (hsv.x - hMin)/(hMax - hMin) * 360.0;","    hsv.y *= s * 1.5;","    hue=hsv.x >= 360.0?hsv.x-360.0:hsv.x;","    hue /= 60.0;","    i = int(hue);","    ff = hue - float(i);","    p = hsv.z * (1.0 - hsv.y);","    q = hsv.z * (1.0 - (hsv.y * ff));","    t = hsv.z * (1.0 - (hsv.y * (1.0 - ff)));","    if(i==0)","        return vec3(hsv.z,t,p);","    else if(i==1)","      return vec3(q,hsv.z,p);","    else if(i==2)","        return vec3(p,hsv.z,t);","    else if(i==3)","        return vec3(p,q,hsv.z);","    else if(i==4)","        return vec3(t,p,hsv.z);","    else","        return vec3(hsv.z,p,q);","}","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);"," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0;"," vec4 backColor = texture2D(uBackCoord,texC);"," vec3 dir = backColor.rgb - frontColor.rgb;"," vec4 vpos = frontColor;"," vec3 Step = dir/uStepsF;"," vec4 accum = vec4(0, 0, 0, 0);"," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);"," vec4 colorValue = vec4(0, 0, 0, 0);"," float opacityFactor = uOpacityVal;"," for(int i = 0; i < uStepsI; i++)"," {","    vec3 gray_val = getVolumeValue(vpos.xyz);","     if(gray_val.z < 0.05 ||","         gray_val.x < minSos ||","         gray_val.x > maxSos ||","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl","       )","         colorValue = vec4(0.0);","     else {","            colorValue.x = gray_val.x;","            colorValue.y = 1.0-gray_val.y/0.6;","            colorValue.z = gray_val.z;","            colorValue.w = 0.1;","            // colorValue.x = gray_val.z;","            // colorValue.y = gray_val.z;","            // colorValue.z = gray_val.z;","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF);","            sample.rgb = (1.0 - accum.a) * hsv2rgb(colorValue.rgb) * sample.a;","            accum += sample;","            if(accum.a>=1.0)","               break;","     }","     //advance the current position","     vpos.xyz += Step;","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)","         break;"," }"," gl_FragColor = accum;","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassGraySeparate={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},uSlicemapWidth:{type:"f",value:-1},uIndexOfImage:{type:"i",value:0},uOutlineOpacity:{type:"f",value:-1},uSosOpacity:{type:"f",value:-1},uAttenOpacity:{type:"f",value:-1},uSurfaceThresholdBot:{type:"f",value:-1},uSurfaceThresholdTop:{type:"f",value:-1},uSosThresholdBot:{type:"f",value:-1},uSosThresholdTop:{type:"f",value:-1},uAttenThresholdBot:{type:"f",value:-1},uAttenThresholdTop:{type:"f",value:-1},uEnableOverlap:{type:"i",value:0},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1},darkness:{type:"f",value:-1}}]),vertexShader:["precision mediump int;","precision mediump float;","attribute vec4 vertColor;","varying vec4 frontColor;","varying vec4 pos;","void main(void)","{","    frontColor = vertColor;","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","    gl_Position = pos; ","}"].join("\n"),fragmentShader:["precision mediump int;","precision mediump float;","varying vec4 frontColor;","varying vec4 pos;","uniform sampler2D uBackCoord;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices;","uniform float uOpacityVal;","uniform float uSlicesOverX;","uniform float uSlicesOverY;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float uSlicemapWidth;","uniform int uIndexOfImage;","uniform float uOutlineOpacity;","uniform float uSosOpacity;","uniform float uAttenOpacity;","uniform float uSurfaceThresholdBot;","uniform float uSurfaceThresholdTop;","uniform float uSosThresholdBot;","uniform float uSosThresholdTop;","uniform float uAttenThresholdBot;","uniform float uAttenThresholdTop;","uniform bool uEnableOverlap;","/////////////////for HSV2RGB","uniform float l;","uniform float s;","uniform float hMin;","uniform float hMax;","uniform float darkness;","///////////////////////////","//Acts like a texture3D using Z slices and trilinear filtering.","vec3 getVolumeValue(vec3 volpos) {","  // float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","  // float delta = 1.0 / sliceSizeX;","  // float  adapted_z = (((volpos.z) * (1.0 - (2.0*delta))) + delta);","  // s1Original = floor(adapted_z*uNumberOfSlices);","  float s1Original, s2Original, s1, s2;","  float dx1, dy1;","  vec2 texpos1,texpos2;","  float slicesPerSprite = uSlicesOverX * uSlicesOverY;","  s1Original = floor(volpos.z*(uNumberOfSlices));","  int tex1Index = int(floor(s1Original / slicesPerSprite));","  s1 = mod(s1Original, slicesPerSprite);","  dx1 = fract(s1/uSlicesOverX);","  dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","  texpos1.x = dx1+(volpos.x/uSlicesOverX);","  texpos1.y = dy1+(volpos.y/uSlicesOverY);","  vec3 value = vec3(0.0,0.0,0.0);","  <% for(var i=0; i < maxTexturesNumber; i++) { %>","      if( tex1Index == <%=i%> )","      {","          value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","      }","      <% if( i < maxTexturesNumber-1 ) { %>","          else","      <% } %>","  <% } %>","  return value;","}","vec3 hsv2rgb(vec3 hsv)","{","    float     hue, p, q, t, ff;","    int        i;","    hsv.z = (darkness - hsv.z) * l;","    hsv.x = (hsv.x - hMin)/(hMax - hMin) * 360.0;","    hsv.y *= s * 1.5;","    hue=hsv.x >= 360.0?hsv.x-360.0:hsv.x;","    hue /= 60.0;","    i = int(hue);","    ff = hue - float(i);","    p = hsv.z * (1.0 - hsv.y);","    q = hsv.z * (1.0 - (hsv.y * ff));","    t = hsv.z * (1.0 - (hsv.y * (1.0 - ff)));","    if(i==0)","        return vec3(hsv.z,t,p);","    else if(i==1)","      return vec3(q,hsv.z,p);","    else if(i==2)","        return vec3(p,hsv.z,t);","    else if(i==3)","        return vec3(p,q,hsv.z);","    else if(i==4)","        return vec3(t,p,hsv.z);","    else","        return vec3(hsv.z,p,q);","}","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);"," vec2 texC = vec2((pos.xy/pos.w) + 1.0) / 2.0;"," vec4 backColor = texture2D(uBackCoord,texC);"," vec3 dir = backColor.rgb - frontColor.rgb;"," // vec3 dir = vec3(0.0,0.0,0.0);"," vec4 vpos = frontColor;"," vec3 Step = dir/uStepsF;"," vec4 accum = vec4(0, 0, 0, 0);"," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);"," vec4 colorValue = vec4(0, 0, 0, 0);"," float opacityFactor = uOpacityVal;"," float surfaceThresholdBot = uSurfaceThresholdBot;"," float surfaceThresholdTop = uSurfaceThresholdTop;"," float sosThresholdBot = uSosThresholdBot;"," float sosThresholdTop = uSosThresholdTop;"," float attenThresholdBot = uAttenThresholdBot;"," float attenThresholdTop = uAttenThresholdTop;"," // float outlineOpacity = uOutlineOpacity;"," float outlineOpacity = 0.1;"," // float sosOpacity = uSosOpacity;"," float sosOpacity = 0.1;"," // float attenOpacity = uAttenOpacity;"," float attenOpacity = 0.1;"," for(int i = 0; i < uStepsI; i++)"," {","    vec3 gray_val = getVolumeValue(vpos.xyz);","     if(gray_val.z < 0.05 ||","         gray_val.x < minSos ||","         gray_val.x > maxSos ||","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl","       )","         colorValue = vec4(0.0);","     else","     {","        colorValue.a = outlineOpacity; //получили opacity для всего изображения","        {","          if (uIndexOfImage==0) //only sos","          {","            colorValue.x = gray_val.y;","            colorValue.y = 1.0-gray_val.y/0.7;","            colorValue.z = gray_val.y/1.8;","          }","          if (uIndexOfImage==1) //only atten","          {","            colorValue.x = gray_val.x;","            colorValue.y = 1.0-gray_val.x/0.6;","            colorValue.z = gray_val.x/1.8;","          }","          if (uIndexOfImage==2) //only refl","          {","              colorValue.z = gray_val.z;","          }","          sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF);","          sample.rgb = (1.0 - accum.a) * hsv2rgb(colorValue.rgb) * sample.a;","          vec3 tmp = vec3(0.3, 0.59, 0.11);","          float grayscale=dot(sample.rgb, tmp);","          accum += vec4(grayscale,grayscale,grayscale,sample.a);","          if(accum.a>=1.0)","             break;","        }","     }","     //advance the current position","     vpos.xyz += Step;","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)","         break;"," }"," gl_FragColor = accum;","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassNearestNeighbour={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uSlicemapWidth:{type:"f",value:-1},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uAbsorptionModeIndex:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},uSteps:{type:"f",value:-1},uZFactor:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["varying vec3 worldSpaceCoords;","varying vec4 projectedCoords;"," ","void main()","{","    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;","    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#ifdef GL_FRAGMENT_PRECISION_HIGH "," // highp is supported "," precision highp int; "," precision highp float; ","#else "," // high is not supported "," precision mediump int; "," precision mediump float; ","#endif ","// Passed from vertex","varying vec3 worldSpaceCoords; ","varying vec4 projectedCoords; ","// Passed from core","uniform sampler2D uBackCoord; ","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uSlicemapWidth;","// Assuming a bounding box of 512x512x512","// ceil( sqrt(3) * 512 ) = 887","const int MAX_STEPS = 887;","// Application specific parameters","uniform float uNumberOfSlices; ","uniform float uMinGrayVal; ","uniform float uMaxGrayVal; ","uniform float uOpacityVal; ","uniform float uColorVal; ","uniform float uAbsorptionModeIndex;","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float uSteps;","uniform float uZFactor;","// uniform int uAvailable_textures_number;","vec4 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    // float dx2, dy2; ","    // float value; ","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float delta = 1.0 / sliceSizeX;","    ","    float adapted_x, adapted_y, adapted_z;","    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;","    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;","    adapted_z = 1.0 - ((volpos.z * (1.0 - (2.0*delta))) + delta);","    s1Original = floor(adapted_z*uNumberOfSlices);","    //s1Original = floor(volpos.z*uNumberOfSlices); ","    // s2Original = min(s1Original + 1.0, uNumberOfSlices);","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    // int tex2Index = int(floor(s2Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    // s2 = mod(s2Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    ","    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;","    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;"," ","    float value2 = 0.0;","    vec4 value1;","    // bool value1Set = false, value2Set = false;","    // int numberOfSlicemaps = int( ceil(uNumberOfSlices / (uSlicesOverX * uSlicesOverY)) );","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","    <% } %>","    return value1;","    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)","    // {","    //     if(x == numberOfSlicemaps)","    //     {","    //         break;","    //     }","    //     if(x == tex1Index) { ","    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ","    //         value1Set = true; ","    //     } ","    //     if(x == tex2Index) { ","    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ","    //         value2Set = true; ","    //     } ","    //     if(value1Set && value2Set) { ","    //         break; ","    //     } ","    // } ","    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices)); ","} ","void main(void) {"," ","    //Transform the coordinates it from [-1;1] to [0;1]","    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,","                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);","    //The back position is the world space position stored in the texture.","    vec3 backPos = texture2D(uBackCoord, texc).xyz;","                ","    //The front position is the world space position of the second render pass.","    vec3 frontPos = worldSpaceCoords;"," ","    //The direction from the front position to back position.","    vec3 dir = backPos - frontPos;","    //vec3 dir = frontPos - backPos;"," ","    float rayLength = length(dir);","    //Calculate how long to increment in each step.","    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uZFactor;","    float delta = 1.0 / steps;","    ","    //The increment in each direction for each step.","    vec3 deltaDirection = normalize(dir) * delta;","    float deltaDirectionLength = length(deltaDirection);","    //Start the ray casting from the front position.","    vec3 currentPosition = frontPos;","    //The color accumulator.","    vec4 accumulatedColor = vec4(0.0);","    //The alpha value accumulated so far.","    float accumulatedAlpha = 0.0;","    ","    //How long has the ray travelled so far.","    float accumulatedLength = 0.0;","    ","    //If we have twice as many samples, we only need ~1/2 the alpha per sample.","    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.","    float alphaScaleFactor = 25.6 * delta;","    ","    vec4 colorSample;","    float alphaSample;","    float alphaCorrection = 1.0;","    ","    //Perform the ray marching iterations","    for(int i = 0; i < MAX_STEPS; i++) {","        //Get the voxel intensity value from the 3D texture.","        //colorSample = sampleAs3DTexture( currentPosition );","        ","        colorSample = getVolumeValue( currentPosition );","        ","        //Allow the alpha correction customization.","        alphaSample = colorSample.a * alphaCorrection;","        ","        //Applying this effect to both the color and alpha accumulation results in more realistic transparency.","        alphaSample *= (1.0 - accumulatedAlpha);","        ","        //Scaling alpha by the number of steps makes the final color invariant to the step size.","        alphaSample *= alphaScaleFactor;","        ","        //Perform the composition.","        accumulatedColor += colorSample * alphaSample;","        ","        //Store the alpha accumulated so far.","        accumulatedAlpha += alphaSample;","        ","        //Advance the ray.","        currentPosition += deltaDirection;","\t\t\t\t\t","        accumulatedLength += deltaDirectionLength;","        ","        //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.","        if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )","            break;","    }","    gl_FragColor = accumulatedColor; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassNearestNeighbourB={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uSlicemapWidth:{type:"f",value:-1},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uAbsorptionModeIndex:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},uSteps:{type:"f",value:-1},uRatio:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["varying vec3 worldSpaceCoords;","varying vec4 projectedCoords;"," ","void main()","{","    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;","    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#ifdef GL_FRAGMENT_PRECISION_HIGH "," // highp is supported "," precision highp int; "," precision highp float; ","#else "," // high is not supported "," precision mediump int; "," precision mediump float; ","#endif ","// Passed from vertex","varying vec3 worldSpaceCoords; ","varying vec4 projectedCoords; ","// Passed from core","uniform sampler2D uBackCoord; ","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uSlicemapWidth;","// Assuming a bounding box of 512x512x512","// ceil( sqrt(3) * 512 ) = 887","const int MAX_STEPS = 887;","// Application specific parameters","uniform float uNumberOfSlices; ","uniform float uMinGrayVal; ","uniform float uMaxGrayVal;","uniform float uOpacityVal; ","uniform float uColorVal; ","uniform float uAbsorptionModeIndex;","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float uSteps;","uniform float uRatio;","// uniform int uAvailable_textures_number;","vec4 getVolumeValue(vec3 volpos)","{","    //if (volpos.z < 0.5)","    //    return vec4(0.0);","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    // float dx2, dy2; ","    // float value; ","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float delta = 1.0 / sliceSizeX;","    ","    float adapted_x, adapted_y, adapted_z;","    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;","    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;","    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);","    s1Original = floor(adapted_z*uNumberOfSlices);","    //s1Original = floor(volpos.z*uNumberOfSlices); ","    //s2Original = min(s1Original + 1.0, uNumberOfSlices);","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    //int tex2Index = int(floor(s2Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    //s2 = mod(s2Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    ","    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;","    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;"," ","    float value2 = 0.0;","    vec4 value1;","    // bool value1Set = false, value2Set = false;","    // int numberOfSlicemaps = int( ceil(uNumberOfSlices / (uSlicesOverX * uSlicesOverY)) );","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","    <% } %>","    return value1;","    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)","    // {","    //     if(x == numberOfSlicemaps)","    //     {","    //         break;","    //     }","    //     if(x == tex1Index) { ","    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ","    //         value1Set = true; ","    //     } ","    //     if(x == tex2Index) { ","    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ","    //         value2Set = true; ","    //     } ","    //     if(value1Set && value2Set) { ","    //         break; ","    //     } ","    // } ","    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices));","}","void main(void) {"," ","    //Transform the coordinates it from [-1;1] to [0;1]","    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,","                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);","    //The back position is the world space position stored in the texture.","    vec3 backPos = texture2D(uBackCoord, texc).xyz;","                ","    //The front position is the world space position of the second render pass.","    vec3 frontPos = worldSpaceCoords;"," ","    //The direction from the front position to back position.","    vec3 dir = backPos - frontPos;","    float rayLength = length(dir);","    //Calculate how long to increment in each step.","    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;","    //float steps = 256.0;","    float delta = 1.0 / steps;","    ","    //The increment in each direction for each step.","    vec3 deltaDirection = normalize(dir) * delta;","    ","    vec3 Step = dir / steps;","    ","    float deltaDirectionLength = length(deltaDirection);","    //vec4 vpos = frontColor;  // currentPosition","    //vec3 Step = dir/uStepsF; // steps","    //Start the ray casting from the front position.","    vec3 currentPosition = frontPos;","    //The color accumulator.","    vec4 accumulatedColor = vec4(0.0);","    //The alpha value accumulated so far.","    float accumulatedAlpha = 0.0;","    ","    //How long has the ray travelled so far.","    float accumulatedLength = 0.0;","    ","    //If we have twice as many samples, we only need ~1/2 the alpha per sample.","    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.","    float alphaScaleFactor = 28.8 * delta;","    ","    vec4 colorSample = vec4(0.0);","    vec4 sample = vec4(0.0); ","    vec4 grayValue;","    float alphaSample;","    float alphaCorrection = 1.0;","    ","    //Perform the ray marching iterations","    for(int i = 0; i < MAX_STEPS; i++) {       ","        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)      ","            break;","        if(accumulatedColor.a>=1.0) ","            break;","        grayValue = getVolumeValue(currentPosition); ","        if(grayValue.z < 0.05 || ","           grayValue.z < 0.0 ||","           grayValue.z > 1.0)  ","            accumulatedColor = vec4(0.0);     ","        else { ","            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;","            colorSample.x = grayValue.z;","            //colorSample.w = alphaScaleFactor;","            colorSample.w = 0.1;","              ","            //sample.a = colorSample.a * 40.0 * (1.0 / steps);","            sample.a = colorSample.a;","            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xxx * sample.a; ","             ","            accumulatedColor += sample; ","        }    ","   ","        //Advance the ray.","        //currentPosition.xyz += deltaDirection;","        currentPosition.xyz += Step;","   ","         ","    } ","    gl_FragColor = accumulatedColor; ","    /*","    for(int i = 0; i < MAX_STEPS; i++) {","        ","        grayValue = getVolumeValue( currentPosition );","        ","        if(grayValue.r < uMinGrayVal || grayValue.r > uMaxGrayVal || grayValue.b < 0.05) { ","            accumulatedColor = vec4(0.0); ","        } else {","            colorSample.rgb = vec3(1.0,0.0,0.0);","            colorSample.a = 1.0;","            ","            alphaSample = colorSample.a * alphaCorrection;","        ","            //Applying this effect to both the color and alpha accumulation results in more realistic transparency.","            alphaSample *= (1.0 - accumulatedAlpha);","        ","            //Scaling alpha by the number of steps makes the final color invariant to the step size.","            alphaSample *= alphaScaleFactor;","        ","            //Perform the composition.","            accumulatedColor += colorSample * alphaSample * 100.0;","        ","            //Store the alpha accumulated so far.","            accumulatedAlpha += alphaSample;","            ","            accumulatedColor = colorSample;","        }","        //Advance the ray.","        currentPosition += deltaDirection;","\t\t\t\t\t","        accumulatedLength += deltaDirectionLength;","        ","        //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.","        if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )","            break;","    }","    gl_FragColor = accumulatedColor;","    */","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassNearestNeighbourG={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uSlicemapWidth:{type:"f",value:-1},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uAbsorptionModeIndex:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},uSteps:{type:"f",value:-1},uRatio:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["varying vec3 worldSpaceCoords;","varying vec4 projectedCoords;"," ","void main()","{","    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;","    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#ifdef GL_FRAGMENT_PRECISION_HIGH "," // highp is supported "," precision highp int; "," precision highp float; ","#else "," // high is not supported "," precision mediump int; "," precision mediump float; ","#endif ","// Passed from vertex","varying vec3 worldSpaceCoords; ","varying vec4 projectedCoords; ","// Passed from core","uniform sampler2D uBackCoord; ","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uSlicemapWidth;","// Assuming a bounding box of 512x512x512","// ceil( sqrt(3) * 512 ) = 887","const int MAX_STEPS = 887;","// Application specific parameters","uniform float uNumberOfSlices; ","uniform float uMinGrayVal; ","uniform float uMaxGrayVal;","uniform float uOpacityVal; ","uniform float uColorVal; ","uniform float uAbsorptionModeIndex;","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float uSteps;","uniform float uRatio;","// uniform int uAvailable_textures_number;","vec4 getVolumeValue(vec3 volpos)","{","    //if (volpos.z < 0.5)","    //    return vec4(0.0);","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    // float dx2, dy2; ","    // float value; ","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float delta = 1.0 / sliceSizeX;","    ","    float adapted_x, adapted_y, adapted_z;","    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;","    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;","    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);","    s1Original = floor(adapted_z*uNumberOfSlices);","    //s1Original = floor(volpos.z*uNumberOfSlices); ","    //s2Original = min(s1Original + 1.0, uNumberOfSlices);","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    //int tex2Index = int(floor(s2Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    //s2 = mod(s2Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    ","    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;","    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;"," ","    float value2 = 0.0;","    vec4 value1;","    // bool value1Set = false, value2Set = false;","    // int numberOfSlicemaps = int( ceil(uNumberOfSlices / (uSlicesOverX * uSlicesOverY)) );","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","    <% } %>","    return value1;","    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)","    // {","    //     if(x == numberOfSlicemaps)","    //     {","    //         break;","    //     }","    //     if(x == tex1Index) { ","    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ","    //         value1Set = true; ","    //     } ","    //     if(x == tex2Index) { ","    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ","    //         value2Set = true; ","    //     } ","    //     if(value1Set && value2Set) { ","    //         break; ","    //     } ","    // } ","    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices));","}","void main(void) {"," ","    //Transform the coordinates it from [-1;1] to [0;1]","    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,","                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);","    //The back position is the world space position stored in the texture.","    vec3 backPos = texture2D(uBackCoord, texc).xyz;","                ","    //The front position is the world space position of the second render pass.","    vec3 frontPos = worldSpaceCoords;"," ","    //The direction from the front position to back position.","    vec3 dir = backPos - frontPos;","    float rayLength = length(dir);","    //Calculate how long to increment in each step.","    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;","    //float steps = 256.0;","    float delta = 1.0 / steps;","    ","    //The increment in each direction for each step.","    vec3 deltaDirection = normalize(dir) * delta;","    ","    vec3 Step = dir / steps;","    ","    float deltaDirectionLength = length(deltaDirection);","    //vec4 vpos = frontColor;  // currentPosition","    //vec3 Step = dir/uStepsF; // steps","    //Start the ray casting from the front position.","    vec3 currentPosition = frontPos;","    //The color accumulator.","    vec4 accumulatedColor = vec4(0.0);","    //The alpha value accumulated so far.","    float accumulatedAlpha = 0.0;","    ","    //How long has the ray travelled so far.","    float accumulatedLength = 0.0;","    ","    //If we have twice as many samples, we only need ~1/2 the alpha per sample.","    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.","    float alphaScaleFactor = 28.8 * delta;","    ","    vec4 colorSample = vec4(0.0);","    vec4 sample = vec4(0.0); ","    vec4 grayValue;","    float alphaSample;","    float alphaCorrection = 1.0;","    ","    //Perform the ray marching iterations","    for(int i = 0; i < MAX_STEPS; i++) {       ","        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)      ","            break;","        if(accumulatedColor.a>=1.0) ","            break;","        grayValue = getVolumeValue(currentPosition); ","        if(grayValue.z < 0.05 || ","           grayValue.y < 0.0 ||","           grayValue.y > 1.0)  ","            accumulatedColor = vec4(0.0);     ","        else { ","            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;","            colorSample.x = grayValue.y;","            //colorSample.w = alphaScaleFactor;","            colorSample.w = 0.1;","              ","            //sample.a = colorSample.a * 40.0 * (1.0 / steps);","            sample.a = colorSample.a;","            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xxx * sample.a; ","             ","            accumulatedColor += sample; ","        }    ","   ","        //Advance the ray.","        //currentPosition.xyz += deltaDirection;","        currentPosition.xyz += Step;","   ","         ","    } ","    gl_FragColor = accumulatedColor; ","    /*","    for(int i = 0; i < MAX_STEPS; i++) {","        ","        grayValue = getVolumeValue( currentPosition );","        ","        if(grayValue.r < uMinGrayVal || grayValue.r > uMaxGrayVal || grayValue.b < 0.05) { ","            accumulatedColor = vec4(0.0); ","        } else {","            colorSample.rgb = vec3(1.0,0.0,0.0);","            colorSample.a = 1.0;","            ","            alphaSample = colorSample.a * alphaCorrection;","        ","            //Applying this effect to both the color and alpha accumulation results in more realistic transparency.","            alphaSample *= (1.0 - accumulatedAlpha);","        ","            //Scaling alpha by the number of steps makes the final color invariant to the step size.","            alphaSample *= alphaScaleFactor;","        ","            //Perform the composition.","            accumulatedColor += colorSample * alphaSample * 100.0;","        ","            //Store the alpha accumulated so far.","            accumulatedAlpha += alphaSample;","            ","            accumulatedColor = colorSample;","        }","        //Advance the ray.","        currentPosition += deltaDirection;","\t\t\t\t\t","        accumulatedLength += deltaDirectionLength;","        ","        //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.","        if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )","            break;","    }","    gl_FragColor = accumulatedColor;","    */","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassNearestNeighbourHSVFusion={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uSlicemapWidth:{type:"f",value:-1},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uAbsorptionModeIndex:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},uSteps:{type:"f",value:-1},uRatio:{type:"f",value:-1},uIndexOfImage:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["varying vec3 worldSpaceCoords;","varying vec4 projectedCoords;"," ","void main()","{","    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;","    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#ifdef GL_FRAGMENT_PRECISION_HIGH"," // highp is supported"," precision highp int;"," precision highp float;","#else"," // high is not supported"," precision mediump int;"," precision mediump float;","#endif","// Passed from vertex","varying vec3 worldSpaceCoords;","varying vec4 projectedCoords;","// Passed from core","uniform sampler2D uBackCoord;","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uSlicemapWidth;","// Assuming a bounding box of 512x512x512","// ceil( sqrt(3) * 512 ) = 887","const int MAX_STEPS = 887;","// Application specific parameters","uniform float uNumberOfSlices;","uniform float uMinGrayVal;","uniform float uMaxGrayVal;","uniform float uOpacityVal;","uniform float uColorVal;","uniform float uAbsorptionModeIndex;","uniform float uSlicesOverX;","uniform float uSlicesOverY;","uniform float uSteps;","uniform float uRatio;","uniform float uIndexOfImage;","// uniform int uAvailable_textures_number;","vec4 getVolumeValue(vec3 volpos)","{","    //if (volpos.z < 0.5)","    //    return vec4(0.0);","    float s1Original, s2Original, s1, s2;","    float dx1, dy1;","    // float dx2, dy2;","    // float value;","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float delta = 1.0 / sliceSizeX;","    float adapted_x, adapted_y, adapted_z;","    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;","    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;","    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) );","    // s1Original = floor(adapted_z*uNumberOfSlices);","    if(adapted_z>0.0) {","        s1Original = floor(adapted_z*uNumberOfSlices);","    } else {","        s1Original = (1.0 - (0.5 / uNumberOfSlices)) * uNumberOfSlices;","    }","    //s1Original = floor(volpos.z*uNumberOfSlices);","    //s2Original = min(s1Original + 1.0, uNumberOfSlices);","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    //int tex2Index = int(floor(s2Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    //s2 = mod(s2Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;","    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;","    float value2 = 0.0;","    vec4 value1;","    // bool value1Set = false, value2Set = false;","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","    <% } %>","    return value1;","}","// x - R, y - G, z - B","// x - H, y - S, z - V","vec3 hsv2rgb(vec3 hsv)","{","    float     hue, p, q, t, ff;","    int        i;",'    //"opacity_factor": 40,','    //"color_factor": 0.4,','    //"x_min": 0,','    //"x_max": 1,','    //"l": 5,','    //"s" : 1,','    //"hMin" : -0.5,','    //"hMax" : 1,','    //"minRefl" : 0,','    //"minSos" : 0,','    //"minAtten" : 0,','    //"maxRefl" : 100,','    //"maxSos" : 100,','    //"maxAtten" : 100,',"    float darkness = 0.4;","    float l = 5.0;","    float s = 1.0;","    float hMin = -0.5;","    float hMax = 1.0;","    hsv.z = (darkness - hsv.z) * l;","    hsv.x = (hsv.x - hMin)/(hMax - hMin) * 360.0;","    hsv.y *= s * 1.5;","    hue=hsv.x >= 360.0?hsv.x-360.0:hsv.x;","    hue /= 60.0;","    i = int(hue);","    ff = hue - float(i);","    p = hsv.z * (1.0 - hsv.y);","    q = hsv.z * (1.0 - (hsv.y * ff));","    t = hsv.z * (1.0 - (hsv.y * (1.0 - ff)));","    if(i==0)","        return vec3(hsv.z,t,p);","    else if(i==1)","      return vec3(q,hsv.z,p);","    else if(i==2)","        return vec3(p,hsv.z,t);","    else if(i==3)","        return vec3(p,q,hsv.z);","    else if(i==4)","        return vec3(t,p,hsv.z);","    else","        return vec3(hsv.z,p,q);","}","void main(void) {","    //Transform the coordinates it from [-1;1] to [0;1]","    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,","                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);","    //The back position is the world space position stored in the texture.","    vec3 backPos = texture2D(uBackCoord, texc).xyz;","    //The front position is the world space position of the second render pass.","    vec3 frontPos = worldSpaceCoords;","    //The direction from the front position to back position.","    vec3 dir = backPos - frontPos;","    float rayLength = length(dir);","    //Calculate how long to increment in each step.","    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;","    //float steps = 256.0;","    float delta = 1.0 / steps;","    //The increment in each direction for each step.","    vec3 deltaDirection = normalize(dir) * delta;","    vec3 Step = dir / steps;","    float deltaDirectionLength = length(deltaDirection);","    //vec4 vpos = frontColor;  // currentPosition","    //vec3 Step = dir/uStepsF; // steps","    //Start the ray casting from the front position.","    vec3 currentPosition = frontPos;","    //The color accumulator.","    vec4 accumulatedColor = vec4(0.0);","    //The alpha value accumulated so far.","    float accumulatedAlpha = 0.0;","    //How long has the ray travelled so far.","    float accumulatedLength = 0.0;","    //If we have twice as many samples, we only need ~1/2 the alpha per sample.","    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.","    float alphaScaleFactor = 28.8 * delta;","    vec4 colorSample = vec4(0.0);","    vec4 sample = vec4(0.0);","    vec4 grayValue;","    float alphaSample;","    float alphaCorrection = 1.0;","    //Perform the ray marching iterations","    for(int i = 0; i < MAX_STEPS; i++) {","        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)","            break;","        if(accumulatedColor.a>=1.0)","            break;","        grayValue = getVolumeValue(currentPosition);","        if(grayValue.z < 0.05 ||","           grayValue.x < 0.0 ||","           grayValue.x > 1.0)","            accumulatedColor = vec4(0.0);","        else {","          if (uIndexOfImage==0.0)","          {","            // colorSample.xyz = grayValue.xyz;","            colorSample.x = grayValue.x;","            colorSample.y = 1.0-grayValue.y/0.6;","            colorSample.z = grayValue.z;","            colorSample.w = 0.04;","            // colorSample.w = 0.04;","            // colorSample.x = grayValue.x;","            // colorSample.y = 1.0-grayValue.x/0.6;","            // colorSample.z = grayValue.x/1.8;","            // colorSample.w = 0.04;","            // colorSample.x = grayValue.y;","            // colorSample.y = 1.0-grayValue.y/0.7;","            // colorSample.z = grayValue.y/1.8;","            // colorSample.w = 0.03;","            // colorSample.x = grayValue.z;","            // colorSample.y = grayValue.z;","            // colorSample.z = grayValue.z;","          }","          if (uIndexOfImage==1.0)","          {","            colorSample.w = 0.04;","            colorSample.x = grayValue.x;","            colorSample.y = 1.0-grayValue.x/0.6;","            colorSample.z = grayValue.x/1.8;","          }","          if (uIndexOfImage==2.0)","          {","            colorSample.w = 0.04;","            colorSample.x = grayValue.y;","            colorSample.y = 1.0-grayValue.y/0.7;","            colorSample.z = grayValue.y/1.8;","          }","          if (uIndexOfImage==3.0)","          {","            colorSample.w = 0.03;","            colorSample.x = grayValue.z;","            colorSample.y = grayValue.z;","            colorSample.z = grayValue.z;","          }","            //sample.a = colorSample.a * 40.0 * (1.0 / steps);","            sample.a = colorSample.a;","            sample.rgb = (1.0 - accumulatedColor.a) * hsv2rgb(colorSample.xyz) * sample.a;","          if(uIndexOfImage==0.0) // multimodality","          {","            accumulatedColor += sample;","            // accumulatedColor += vec4(currentPosition.xyz,sample.a);","          }","          else // single modality","          {","            vec3 tmp = vec3(0.3, 0.59, 0.11);","            float grayscale=dot(sample.rgb, tmp);","            accumulatedColor += vec4(grayscale,grayscale,grayscale,sample.a);","          }","        }","        //Advance the ray.","        //currentPosition.xyz += deltaDirection;","        currentPosition.xyz += Step;","    }","    gl_FragColor = accumulatedColor;","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassNearestNeighbourR={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uSlicemapWidth:{type:"f",value:-1},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uAbsorptionModeIndex:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},uSteps:{type:"f",value:-1},uRatio:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["varying vec3 worldSpaceCoords;","varying vec4 projectedCoords;"," ","void main()","{","    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;","    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#ifdef GL_FRAGMENT_PRECISION_HIGH "," // highp is supported "," precision highp int; "," precision highp float; ","#else "," // high is not supported "," precision mediump int; "," precision mediump float; ","#endif ","// Passed from vertex","varying vec3 worldSpaceCoords; ","varying vec4 projectedCoords; ","// Passed from core","uniform sampler2D uBackCoord; ","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uSlicemapWidth;","// Assuming a bounding box of 512x512x512","// ceil( sqrt(3) * 512 ) = 887","const int MAX_STEPS = 887;","// Application specific parameters","uniform float uNumberOfSlices; ","uniform float uMinGrayVal; ","uniform float uMaxGrayVal;","uniform float uOpacityVal; ","uniform float uColorVal; ","uniform float uAbsorptionModeIndex;","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float uSteps;","uniform float uRatio;","// uniform int uAvailable_textures_number;","vec4 getVolumeValue(vec3 volpos)","{","    //if (volpos.z < 0.5)","    //    return vec4(0.0);","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    // float dx2, dy2; ","    // float value; ","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float delta = 1.0 / sliceSizeX;","    ","    float adapted_x, adapted_y, adapted_z;","    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;","    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;","    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);","    s1Original = floor(adapted_z*uNumberOfSlices);","    //s1Original = floor(volpos.z*uNumberOfSlices); ","    //s2Original = min(s1Original + 1.0, uNumberOfSlices);","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    //int tex2Index = int(floor(s2Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    //s2 = mod(s2Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    ","    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;","    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;"," ","    float value2 = 0.0;","    vec4 value1;","    // bool value1Set = false, value2Set = false;","    // int numberOfSlicemaps = int( ceil(uNumberOfSlices / (uSlicesOverX * uSlicesOverY)) );","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","    <% } %>","    return value1;","    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)","    // {","    //     if(x == numberOfSlicemaps)","    //     {","    //         break;","    //     }","    //     if(x == tex1Index) { ","    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ","    //         value1Set = true; ","    //     } ","    //     if(x == tex2Index) { ","    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ","    //         value2Set = true; ","    //     } ","    //     if(value1Set && value2Set) { ","    //         break; ","    //     } ","    // } ","    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices));","}","void main(void) {"," ","    //Transform the coordinates it from [-1;1] to [0;1]","    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,","                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);","    //The back position is the world space position stored in the texture.","    vec3 backPos = texture2D(uBackCoord, texc).xyz;","                ","    //The front position is the world space position of the second render pass.","    vec3 frontPos = worldSpaceCoords;"," ","    //The direction from the front position to back position.","    vec3 dir = backPos - frontPos;","    float rayLength = length(dir);","    //Calculate how long to increment in each step.","    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;","    //float steps = 256.0;","    float delta = 1.0 / steps;","    ","    //The increment in each direction for each step.","    vec3 deltaDirection = normalize(dir) * delta;","    ","    vec3 Step = dir / steps;","    ","    float deltaDirectionLength = length(deltaDirection);","    //vec4 vpos = frontColor;  // currentPosition","    //vec3 Step = dir/uStepsF; // steps","    //Start the ray casting from the front position.","    vec3 currentPosition = frontPos;","    //The color accumulator.","    vec4 accumulatedColor = vec4(0.0);","    //The alpha value accumulated so far.","    float accumulatedAlpha = 0.0;","    ","    //How long has the ray travelled so far.","    float accumulatedLength = 0.0;","    ","    //If we have twice as many samples, we only need ~1/2 the alpha per sample.","    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.","    float alphaScaleFactor = 28.8 * delta;","    ","    vec4 colorSample = vec4(0.0);","    vec4 sample = vec4(0.0); ","    vec4 grayValue;","    float alphaSample;","    float alphaCorrection = 1.0;","    ","    //Perform the ray marching iterations","    for(int i = 0; i < MAX_STEPS; i++) {       ","        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)      ","            break;","        if(accumulatedColor.a>=1.0) ","            break;","        grayValue = getVolumeValue(currentPosition); ","        if(grayValue.z < 0.05 || ","           grayValue.x < 0.0 ||","           grayValue.x > 1.0)  ","            accumulatedColor = vec4(0.0);     ","        else { ","            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;","            colorSample.x = grayValue.x;","            //colorSample.w = alphaScaleFactor;","            colorSample.w = 0.1;","              ","            //sample.a = colorSample.a * 40.0 * (1.0 / steps);","            sample.a = colorSample.a;","            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xxx * sample.a; ","             ","            accumulatedColor += sample; ","        }    ","   ","        //Advance the ray.","        //currentPosition.xyz += deltaDirection;","        currentPosition.xyz += Step;","   ","         ","    } ","    gl_FragColor = accumulatedColor; ","    /*","    for(int i = 0; i < MAX_STEPS; i++) {","        ","        grayValue = getVolumeValue( currentPosition );","        ","        if(grayValue.r < uMinGrayVal || grayValue.r > uMaxGrayVal || grayValue.b < 0.05) { ","            accumulatedColor = vec4(0.0); ","        } else {","            colorSample.rgb = vec3(1.0,0.0,0.0);","            colorSample.a = 1.0;","            ","            alphaSample = colorSample.a * alphaCorrection;","        ","            //Applying this effect to both the color and alpha accumulation results in more realistic transparency.","            alphaSample *= (1.0 - accumulatedAlpha);","        ","            //Scaling alpha by the number of steps makes the final color invariant to the step size.","            alphaSample *= alphaScaleFactor;","        ","            //Perform the composition.","            accumulatedColor += colorSample * alphaSample * 100.0;","        ","            //Store the alpha accumulated so far.","            accumulatedAlpha += alphaSample;","            ","            accumulatedColor = colorSample;","        }","        //Advance the ray.","        currentPosition += deltaDirection;","\t\t\t\t\t","        accumulatedLength += deltaDirectionLength;","        ","        //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.","        if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )","            break;","    }","    gl_FragColor = accumulatedColor;","    */","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassNearestNeighbourRGB={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uSlicemapWidth:{type:"f",value:-1},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uAbsorptionModeIndex:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},uSteps:{type:"f",value:-1},uRatio:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["varying vec3 worldSpaceCoords;","varying vec4 projectedCoords;"," ","void main()","{","    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;","    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#ifdef GL_FRAGMENT_PRECISION_HIGH "," // highp is supported "," precision highp int; "," precision highp float; ","#else "," // high is not supported "," precision mediump int; "," precision mediump float; ","#endif ","// Passed from vertex","varying vec3 worldSpaceCoords; ","varying vec4 projectedCoords; ","// Passed from core","uniform sampler2D uBackCoord; ","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uSlicemapWidth;","// Assuming a bounding box of 512x512x512","// ceil( sqrt(3) * 512 ) = 887","const int MAX_STEPS = 887;","// Application specific parameters","uniform float uNumberOfSlices; ","uniform float uMinGrayVal; ","uniform float uMaxGrayVal;","uniform float uOpacityVal; ","uniform float uColorVal; ","uniform float uAbsorptionModeIndex;","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float uSteps;","uniform float uRatio;","// uniform int uAvailable_textures_number;","vec4 getVolumeValue(vec3 volpos)","{","    //if (volpos.z < 0.5)","    //    return vec4(0.0);","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    // float dx2, dy2; ","    // float value; ","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float delta = 1.0 / sliceSizeX;","    ","    float adapted_x, adapted_y, adapted_z;","    adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;","    adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;","    adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);","    s1Original = floor(adapted_z*uNumberOfSlices);","    //s1Original = floor(volpos.z*uNumberOfSlices); ","    //s2Original = min(s1Original + 1.0, uNumberOfSlices);","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    //int tex2Index = int(floor(s2Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    //s2 = mod(s2Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    ","    texpos1.x = dx1+(floor(adapted_x*sliceSizeX)+0.5)/uSlicemapWidth;","    texpos1.y = dy1+(floor(adapted_y*sliceSizeY)+0.5)/uSlicemapWidth;"," ","    float value2 = 0.0;","    vec4 value1;","    // bool value1Set = false, value2Set = false;","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","    <% } %>","    return value1;","    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)","    // {","    //     if(x == numberOfSlicemaps)","    //     {","    //         break;","    //     }","    //     if(x == tex1Index) { ","    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ","    //         value1Set = true; ","    //     } ","    //     if(x == tex2Index) { ","    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ","    //         value2Set = true; ","    //     } ","    //     if(value1Set && value2Set) { ","    //         break; ","    //     } ","    // } ","    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices));","}","void main(void) {"," ","    //Transform the coordinates it from [-1;1] to [0;1]","    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,","                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);","    //The back position is the world space position stored in the texture.","    vec3 backPos = texture2D(uBackCoord, texc).xyz;","                ","    //The front position is the world space position of the second render pass.","    vec3 frontPos = worldSpaceCoords;"," ","    //The direction from the front position to back position.","    vec3 dir = backPos - frontPos;","    float rayLength = length(dir);","    //Calculate how long to increment in each step.","    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;","    //float steps = 256.0;","    float delta = 1.0 / steps;","    ","    //The increment in each direction for each step.","    vec3 deltaDirection = normalize(dir) * delta;","    ","    vec3 Step = dir / steps;","    ","    float deltaDirectionLength = length(deltaDirection);","    //vec4 vpos = frontColor;  // currentPosition","    //vec3 Step = dir/uStepsF; // steps","    //Start the ray casting from the front position.","    vec3 currentPosition = frontPos;","    //The color accumulator.","    vec4 accumulatedColor = vec4(0.0);","    //The alpha value accumulated so far.","    float accumulatedAlpha = 0.0;","    ","    //How long has the ray travelled so far.","    float accumulatedLength = 0.0;","    ","    //If we have twice as many samples, we only need ~1/2 the alpha per sample.","    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.","    float alphaScaleFactor = 28.8 * delta;","    ","    vec4 colorSample = vec4(0.0);","    vec4 sample = vec4(0.0); ","    vec4 grayValue;","    float alphaSample;","    float alphaCorrection = 1.0;","    ","    //Perform the ray marching iterations","    for(int i = 0; i < MAX_STEPS; i++) {       ","        if(currentPosition.x > 1.0 || currentPosition.y > 1.0 || currentPosition.z > 1.0 || currentPosition.x < 0.0 || currentPosition.y < 0.0 || currentPosition.z < 0.0)      ","            break;","        if(accumulatedColor.a>=1.0) ","            break;","        grayValue = getVolumeValue(currentPosition); ","        if(grayValue.z < 0.05 || ","           grayValue.x < 0.0 ||","           grayValue.x > 1.0)  ","            accumulatedColor = vec4(0.0);     ","        else { ","            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;","            colorSample.xyz = grayValue.xyz;","            //colorSample.w = alphaScaleFactor;","            colorSample.w = 0.1;","              ","            //sample.a = colorSample.a * 40.0 * (1.0 / steps);","            sample.a = colorSample.a;","            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xyz * sample.a; ","             ","            accumulatedColor += sample; ","        }    ","   ","        //Advance the ray.","        //currentPosition.xyz += deltaDirection;","        currentPosition.xyz += Step;","   ","         ","    } ","    gl_FragColor = accumulatedColor;","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassNormalFusion={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},uSteps:{type:"f",value:-1},uSetViewMode:{type:"i",value:0},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uSosThresholdBot:{type:"f",value:-1},uSosThresholdTop:{type:"f",value:-1},uAttenThresholdBot:{type:"f",value:-1},uAttenThresholdTop:{type:"f",value:-1},uSlicemapWidth:{type:"f",value:-1},l:{type:"f",value:-1}}]),vertexShader:["precision mediump int;","precision mediump float;","attribute vec4 vertColor;","varying vec4 frontColor;","varying vec4 pos;","void main(void)","{","    frontColor = vertColor;","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","    gl_Position = pos;","}"].join("\n"),fragmentShader:["precision mediump int;","precision mediump float;","varying vec4 frontColor;","varying vec4 pos;","uniform sampler2D uBackCoord;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices;","uniform float uOpacityVal;","uniform float uSlicesOverX;","uniform float uSlicesOverY;","uniform float darkness;","uniform float uSteps;","uniform int uSetViewMode;","uniform float uMinGrayVal;","uniform float uMaxGrayVal;","uniform float uSosThresholdBot;","uniform float uSosThresholdTop;","uniform float uAttenThresholdBot;","uniform float uAttenThresholdTop;","uniform float uSlicemapWidth;","uniform float l;","//Acts like a texture3D using Z slices and trilinear filtering.","vec3 getVolumeValue(vec3 volpos) {","  float s1Original, s2Original, s1, s2;","  float dx1, dy1;","  vec2 texpos1,texpos2;","  float slicesPerSprite = uSlicesOverX * uSlicesOverY;","  s1Original = floor(volpos.z*(uNumberOfSlices));","  int tex1Index = int(floor(s1Original / slicesPerSprite));","  s1 = mod(s1Original, slicesPerSprite);","  dx1 = fract(s1/uSlicesOverX);","  dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","  texpos1.x = dx1+(volpos.x/uSlicesOverX);","  texpos1.y = dy1+(volpos.y/uSlicesOverY);","  vec3 value = vec3(0.0,0.0,0.0);","  <% for(var i=0; i < maxTexturesNumber; i++) { %>","      if( tex1Index == <%=i%> )","      {","          value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","      }","      <% if( i < maxTexturesNumber-1 ) { %>","          else","      <% } %>","  <% } %>","  return value;","}","// Compute the Normal around the current voxel","vec3 getNormal(vec3 at) {","  float xw = uSlicemapWidth / uSlicesOverX;","  float yw = uSlicemapWidth / uSlicesOverY;","  float zw = uNumberOfSlices;","  float fSliceLower, fSliceUpper, s1, s2;","  float dx1, dy1, dx2, dy2;","  int iTexLowerIndex, iTexUpperIndex;","  vec2 texpos1,texpos2;","  float slicesPerSprite = uSlicesOverX * uSlicesOverY;","  fSliceLower = floor(at.z*uNumberOfSlices); // z value is between 0 and 1. Multiplying the total number of slices","                                             // gives the position in between. By flooring the value, you get the lower","                                             // slice position.","  fSliceUpper = min(fSliceLower + 1.0, uNumberOfSlices); // return the mininimum between the two values","                                                         // act as a upper clamp.","  // At this point, we get our lower slice and upper slice","  // Now we need to get which texture image contains our slice.","  iTexLowerIndex = int(floor(fSliceLower / slicesPerSprite));","  iTexUpperIndex = int(floor(fSliceUpper / slicesPerSprite));","  // mod returns the value of x modulo y. This is computed as x - y * floor(x/y).","  s1 = mod(fSliceLower, slicesPerSprite); // returns the index of slice in slicemap","  s2 = mod(fSliceUpper, slicesPerSprite);","  dx1 = fract(s1/uSlicesOverX);","  dy1 = floor(s1/uSlicesOverY)/uSlicesOverY; // first term is the row within the slicemap","                                             // second division is normalize along y-axis","  dx2 = fract(s2/uSlicesOverX);","  dy2 = floor(s2/uSlicesOverY)/uSlicesOverY; // first term is the row within the slicemap","                                             // second division is normalize along y-axis","  float weight = at.z - floor(at.z);","  float w1 = at.z - floor(at.z);","  float w0 = (at.z - (1.0/zw)) - floor(at.z);","  float w2 = (at.z + (1.0/zw)) - floor(at.z);","  float fx, fy, fz;","  float L0, L1, L2, L3, L4, L5, L6, L7, L8;","  float H0, H1, H2, H3, H4, H5, H6, H7, H8;","  <% for(var i=0; i < maxTexturesNumber; i++) { %>","      if( iTexLowerIndex == <%=i%> )","      {","          texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);","          texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);","          L0 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);","          texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);","          L1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);","          texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);","          L2 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);","          texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);","          L3 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);","          texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);","          L4 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);","          texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);","          L5 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);","          texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);","          L6 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);","          texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);","          L7 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);","          texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);","          L8 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","      }","      if( iTexUpperIndex == <%=i%> ) {","          texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);","          texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);","          H0 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);","          texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);","          H1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);","          texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);","          H2 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);","          texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);","          H3 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);","          texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);","          H4 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);","          texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);","          H5 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);","          texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);","          H6 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);","          texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);","          H7 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","          texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);","          texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);","          H8 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","      }","  <% } %>","  // we need to get interpolation of 2 x points","  // x direction","  // -1 -3 -1   0  0  0   1  3  1","  // -3 -6 -3   0  0  0   3  6  3","  // -1 -3 -1   0  0  0   1  3  1","  // y direction","  //  1  3  1   3  6  3   1  3  1","  //  0  0  0   0  0  0   0  0  0","  // -1 -3 -1  -3 -6 -3  -1 -3 -1","  // z direction","  // -1  0  1   -3  0  3   -1  0  1","  // -3  0  3   -6  0  6   -3  0  3","  // -1  0  1   -3  0  3   -1  0  1","  fx =  ((w0 * (H0 - L0)) + L0) * -1.0;","  fx += ((w1 * (H0 - L0)) + L0) * -3.0;","  fx += ((w2 * (H0 - L0)) + L0) * -1.0;","  fx += ((w0 * (H3 - L3)) + L3) * -3.0;","  fx += ((w1 * (H3 - L3)) + L3) * -6.0;","  fx += ((w2 * (H3 - L3)) + L3) * -3.0;","  fx += ((w0 * (H6 - L6)) + L6) * -1.0;","  fx += ((w1 * (H6 - L6)) + L6) * -3.0;","  fx += ((w2 * (H6 - L6)) + L6) * -1.0;","  fx += ((w0 * (H1 - L1)) + L1) * 0.0;","  fx += ((w1 * (H1 - L1)) + L1) * 0.0;","  fx += ((w2 * (H1 - L1)) + L1) * 0.0;","  fx += ((w0 * (H4 - L4)) + L4) * 0.0;","  fx += ((w1 * (H4 - L4)) + L4) * 0.0;","  fx += ((w2 * (H4 - L4)) + L4) * 0.0;","  fx += ((w0 * (H7 - L7)) + L7) * 0.0;","  fx += ((w1 * (H7 - L7)) + L7) * 0.0;","  fx += ((w2 * (H7 - L7)) + L7) * 0.0;","  fx += ((w0 * (H2 - L2)) + L2) * 1.0;","  fx += ((w1 * (H2 - L2)) + L2) * 3.0;","  fx += ((w2 * (H2 - L2)) + L2) * 1.0;","  fx += ((w0 * (H5 - L5)) + L5) * 3.0;","  fx += ((w1 * (H5 - L5)) + L5) * 6.0;","  fx += ((w2 * (H5 - L5)) + L5) * 3.0;","  fx += ((w0 * (H8 - L8)) + L8) * 1.0;","  fx += ((w1 * (H8 - L8)) + L8) * 3.0;","  fx += ((w2 * (H8 - L8)) + L8) * 1.0;","  fy =  ((w0 * (H0 - L0)) + L0) * 1.0;","  fy += ((w1 * (H0 - L0)) + L0) * 3.0;","  fy += ((w2 * (H0 - L0)) + L0) * 1.0;","  fy += ((w0 * (H3 - L3)) + L3) * 0.0;","  fy += ((w1 * (H3 - L3)) + L3) * 0.0;","  fy += ((w2 * (H3 - L3)) + L3) * 0.0;","  fy += ((w0 * (H6 - L6)) + L6) * -1.0;","  fy += ((w1 * (H6 - L6)) + L6) * -3.0;","  fy += ((w2 * (H6 - L6)) + L6) * -1.0;","  fy += ((w0 * (H1 - L1)) + L1) * 3.0;","  fy += ((w1 * (H1 - L1)) + L1) * 6.0;","  fy += ((w2 * (H1 - L1)) + L1) * 3.0;","  fy += ((w0 * (H4 - L4)) + L4) * 0.0;","  fy += ((w1 * (H4 - L4)) + L4) * 0.0;","  fy += ((w2 * (H4 - L4)) + L4) * 0.0;","  fy += ((w0 * (H7 - L7)) + L7) * -3.0;","  fy += ((w1 * (H7 - L7)) + L7) * -6.0;","  fy += ((w2 * (H7 - L7)) + L7) * -3.0;","  fy += ((w0 * (H2 - L2)) + L2) * 1.0;","  fy += ((w1 * (H2 - L2)) + L2) * 3.0;","  fy += ((w2 * (H2 - L2)) + L2) * 1.0;","  fy += ((w0 * (H5 - L5)) + L5) * 0.0;","  fy += ((w1 * (H5 - L5)) + L5) * 0.0;","  fy += ((w2 * (H5 - L5)) + L5) * 0.0;","  fy += ((w0 * (H8 - L8)) + L8) * -1.0;","  fy += ((w1 * (H8 - L8)) + L8) * -3.0;","  fy += ((w2 * (H8 - L8)) + L8) * -1.0;","  fz =  ((w0 * (H0 - L0)) + L0) * -1.0;","  fz += ((w1 * (H0 - L0)) + L0) * 0.0;","  fz += ((w2 * (H0 - L0)) + L0) * 1.0;","  fz += ((w0 * (H3 - L3)) + L3) * -3.0;","  fz += ((w1 * (H3 - L3)) + L3) * 0.0;","  fz += ((w2 * (H3 - L3)) + L3) * 3.0;","  fz += ((w0 * (H6 - L6)) + L6) * -1.0;","  fz += ((w1 * (H6 - L6)) + L6) * 0.0;","  fz += ((w2 * (H6 - L6)) + L6) * 1.0;","  fz += ((w0 * (H1 - L1)) + L1) * -3.0;","  fz += ((w1 * (H1 - L1)) + L1) * 0.0;","  fz += ((w2 * (H1 - L1)) + L1) * 3.0;","  fz += ((w0 * (H4 - L4)) + L4) * -6.0;","  fz += ((w1 * (H4 - L4)) + L4) * 0.0;","  fz += ((w2 * (H4 - L4)) + L4) * 6.0;","  fz += ((w0 * (H7 - L7)) + L7) * -3.0;","  fz += ((w1 * (H7 - L7)) + L7) * 0.0;","  fz += ((w2 * (H7 - L7)) + L7) * 3.0;","  fz += ((w0 * (H2 - L2)) + L2) * -1.0;","  fz += ((w1 * (H2 - L2)) + L2) * 0.0;","  fz += ((w2 * (H2 - L2)) + L2) * 1.0;","  fz += ((w0 * (H5 - L5)) + L5) * -3.0;","  fz += ((w1 * (H5 - L5)) + L5) * 0.0;","  fz += ((w2 * (H5 - L5)) + L5) * 3.0;","  fz += ((w0 * (H8 - L8)) + L8) * -1.0;","  fz += ((w1 * (H8 - L8)) + L8) * 0.0;","  fz += ((w2 * (H8 - L8)) + L8) * 1.0;","  vec3 n = vec3( fx/27.0 , fy/27.0 , fz/27.0 );","  return n;","}","// returns intensity of reflected ambient lighting","const vec3 u_intensity = vec3(0.1, 0.1, 0.1);","vec3 ambientLighting(vec3 lightColor) {","    vec3 u_matAmbientReflectance = lightColor;","    const vec3 u_lightAmbientIntensity = u_intensity;","    return u_matAmbientReflectance * u_lightAmbientIntensity;","}","// returns intensity of diffuse reflection","vec3 diffuseLighting(in vec3 N, in vec3 L, vec3 lightColor) {","    vec3 u_matDiffuseReflectance = lightColor;","    const vec3 u_lightDiffuseIntensity = vec3(0.6, 0.6, 0.6);","    // calculation as for Lambertian reflection","    float diffuseTerm = dot(N, L);","    if (diffuseTerm > 1.0) {","        diffuseTerm = 1.0;","    } else if (diffuseTerm < 0.0) {","        diffuseTerm = 0.0;","    }","    return u_matDiffuseReflectance * u_lightDiffuseIntensity * diffuseTerm;","}","// returns intensity of specular reflection","vec3 specularLighting(in vec3 N, in vec3 L, in vec3 V, vec3 lightColor) {","    float specularTerm = 0.0;","    // const vec3 u_lightSpecularIntensity = vec3(0, 1, 0);","    const vec3 u_lightSpecularIntensity = u_intensity;","    vec3 u_matSpecularReflectance = lightColor;","    const float u_matShininess = 5.0;","   // calculate specular reflection only if","   // the surface is oriented to the light source","   if(dot(N, L) > 0.0)","   {","      vec3 e = normalize(-V);","      vec3 r = normalize(-reflect(L, N));","      specularTerm = pow(max(dot(r, e), 0.0), u_matShininess);","   }","   return u_matSpecularReflectance * u_lightSpecularIntensity * specularTerm;","}","void main(void) {","    const int uStepsI = 256;","    vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0;","    vec4 backColor = texture2D(uBackCoord,texC);","    vec3 dir = backColor.rgb - frontColor.rgb;","    vec4 vpos = frontColor;","    vec3 posAlongN;","    vec3 Step = dir/uSteps;","    vec4 accum = vec4(0, 0, 0, 0);","    vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);","    vec4 colorValue = vec4(0, 0, 0, 0);","    float opacityFactor = uOpacityVal;","    vec3 surfColor = vec3(0.45);","    vec3 lightPos[3];","    lightPos[0] = vec3(1, 1, 1);","    lightPos[1] = vec3(-1, -1, -1);","    lightPos[2] = vec3(1, 1, -1);","    for(int i = 0; i < uStepsI; i++) {","        vec3 gray_val = getVolumeValue(vpos.xyz).xyz;","        if(gray_val.z < 0.05 ||","           gray_val.x < uMinGrayVal ||","           gray_val.x > uMaxGrayVal)","            colorValue = vec4(0.0);","        else {","            colorValue.x = (darkness * 2.0 - gray_val.x) * l * 0.4;","            colorValue.w = 0.1;","            vec3 V = normalize(cameraPosition - vpos.xyz);","            vec3 N = normalize(getNormal(vpos.xyz));","            vec3 normStep = N / uSteps;","            posAlongN = vpos.xyz;","            for (int j = 0; j < 72; j++) {","              if (gray_val.r > uSosThresholdBot && gray_val.r < uSosThresholdTop) {","                surfColor = vec3(0.8, 0.2, 0.0);","                break;","              }","              if (gray_val.g > uAttenThresholdBot && gray_val.g < uAttenThresholdTop) {","                surfColor = vec3(0.0, 0.8, 0.0);","                break;","              }","              gray_val = getVolumeValue(posAlongN).xyz;","              posAlongN.xyz += normStep;","            }","            for(int light_i = 0; light_i < 3; ++light_i) {","              vec3 L = normalize(lightPos[light_i] - vpos.xyz);","              vec3 Iamb = ambientLighting(surfColor);","              vec3 Idif = diffuseLighting(N, L, surfColor);","              vec3 Ispe = specularLighting(N, L, V, surfColor);","              sample.rgb += (Iamb + Idif + Ispe);","            }","            sample.a = 1.0;","            accum += sample;","            if(accum.a>=1.0)","               break;","        }","        //advance the current position","        vpos.xyz += Step;","        if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)","            break;","    }","    gl_FragColor = accum;","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassSoebel={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},uLightPos:{type:"v3",value:new THREE.Vector3(0,0,0)},uSetViewMode:{type:"i",value:0},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uSlicemapWidth:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int;","precision mediump float;","attribute vec4 vertColor;","varying vec4 frontColor;","varying vec4 pos;","void main(void)","{","    frontColor = vertColor;","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","    gl_Position = pos;","}"].join("\n"),fragmentShader:["// This is an experimental shader to implement","// blinn phong shading model.","// In this example, I use the USCT breast model","// with a total of 144 slices as the dataset.","// Hence the gradient operator is divided by 144 for","// a single unit. Uncomment line 271 to see the normals","// calculated by the gradient operator function.","precision mediump int;","precision mediump float;","varying vec4 frontColor;","varying vec4 pos;","uniform sampler2D uBackCoord;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices;","uniform float uOpacityVal;","uniform float uSlicesOverX;","uniform float uSlicesOverY;","uniform float darkness;","uniform vec3 uLightPos;","uniform int uSetViewMode;","uniform float uMinGrayVal;","uniform float uMaxGrayVal;","uniform float uSlicemapWidth;","uniform float l;","uniform float s;","uniform float hMin;","uniform float hMax;","float xw = uSlicemapWidth / uSlicesOverX;","float yw = uSlicemapWidth / uSlicesOverY;","float zw = uNumberOfSlices;","//Acts like a texture3D using Z slices and trilinear filtering.","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2;","    float dx1, dy1;","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    s1Original = floor(volpos.z*uNumberOfSlices);","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0);","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","}","// Compute the Normal around the current voxel","vec3 getNormal(vec3 at)","{","    float fSliceLower, fSliceUpper, s1, s2;","    float dx1, dy1, dx2, dy2;","    int iTexLowerIndex, iTexUpperIndex;","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    fSliceLower = floor(at.z*uNumberOfSlices); // z value is between 0 and 1. Multiplying the total number of slices","                                               // gives the position in between. By flooring the value, you get the lower","                                               // slice position.","    fSliceUpper = min(fSliceLower + 1.0, uNumberOfSlices); // return the mininimum between the two values","                                                           // act as a upper clamp.","    // At this point, we get our lower slice and upper slice","    // Now we need to get which texture image contains our slice.","    iTexLowerIndex = int(floor(fSliceLower / slicesPerSprite));","    iTexUpperIndex = int(floor(fSliceUpper / slicesPerSprite));","    // mod returns the value of x modulo y. This is computed as x - y * floor(x/y).","    s1 = mod(fSliceLower, slicesPerSprite); // returns the index of slice in slicemap","    s2 = mod(fSliceUpper, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY; // first term is the row within the slicemap","                                               // second division is normalize along y-axis","    dx2 = fract(s2/uSlicesOverX);","    dy2 = floor(s2/uSlicesOverY)/uSlicesOverY; // first term is the row within the slicemap","                                               // second division is normalize along y-axis","    float weight = at.z - floor(at.z);","    float w1 = at.z - floor(at.z);","    float w0 = (at.z - (1.0/zw)) - floor(at.z);","    float w2 = (at.z + (1.0/zw)) - floor(at.z);","    float fx, fy, fz;","    float L0, L1, L2, L3, L4, L5, L6, L7, L8;","    float H0, H1, H2, H3, H4, H5, H6, H7, H8;","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( iTexLowerIndex == <%=i%> )","        {","            texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);","            texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);","            L0 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);","            texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);","            L1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);","            texpos1.y = dy1+((at.y + 1.0/yw)/uSlicesOverY);","            L2 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);","            texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);","            L3 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);","            texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);","            L4 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);","            texpos1.y = dy1+((at.y + 0.0/yw)/uSlicesOverY);","            L5 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx1+((at.x - 1.0/xw)/uSlicesOverX);","            texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);","            L6 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx1+((at.x + 0.0/xw)/uSlicesOverX);","            texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);","            L7 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx1+((at.x + 1.0/xw)/uSlicesOverX);","            texpos1.y = dy1+((at.y - 1.0/yw)/uSlicesOverY);","            L8 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","        }","        if( iTexUpperIndex == <%=i%> ) {","            texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);","            texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);","            H0 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);","            texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);","            H1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);","            texpos1.y = dy2+((at.y + 1.0/yw)/uSlicesOverY);","            H2 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);","            texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);","            H3 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);","            texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);","            H4 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);","            texpos1.y = dy2+((at.y + 0.0/yw)/uSlicesOverY);","            H5 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx2+((at.x - 1.0/xw)/uSlicesOverX);","            texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);","            H6 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx2+((at.x + 0.0/xw)/uSlicesOverX);","            texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);","            H7 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","            texpos1.x = dx2+((at.x + 1.0/xw)/uSlicesOverX);","            texpos1.y = dy2+((at.y - 1.0/yw)/uSlicesOverY);","            H8 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","        }","    <% } %>","    // we need to get interpolation of 2 x points","    // x direction","    // -1 -3 -1   0  0  0   1  3  1","    // -3 -6 -3   0  0  0   3  6  3","    // -1 -3 -1   0  0  0   1  3  1","    // y direction","    //  1  3  1   3  6  3   1  3  1","    //  0  0  0   0  0  0   0  0  0","    // -1 -3 -1  -3 -6 -3  -1 -3 -1","    // z direction","    // -1  0  1   -3  0  3   -1  0  1","    // -3  0  3   -6  0  6   -3  0  3","    // -1  0  1   -3  0  3   -1  0  1","    fx =  ((w0 * (H0 - L0)) + L0) * -1.0;","    fx += ((w1 * (H0 - L0)) + L0) * -3.0;","    fx += ((w2 * (H0 - L0)) + L0) * -1.0;","    fx += ((w0 * (H3 - L3)) + L3) * -3.0;","    fx += ((w1 * (H3 - L3)) + L3) * -6.0;","    fx += ((w2 * (H3 - L3)) + L3) * -3.0;","    fx += ((w0 * (H6 - L6)) + L6) * -1.0;","    fx += ((w1 * (H6 - L6)) + L6) * -3.0;","    fx += ((w2 * (H6 - L6)) + L6) * -1.0;","    fx += ((w0 * (H1 - L1)) + L1) * 0.0;","    fx += ((w1 * (H1 - L1)) + L1) * 0.0;","    fx += ((w2 * (H1 - L1)) + L1) * 0.0;","    fx += ((w0 * (H4 - L4)) + L4) * 0.0;","    fx += ((w1 * (H4 - L4)) + L4) * 0.0;","    fx += ((w2 * (H4 - L4)) + L4) * 0.0;","    fx += ((w0 * (H7 - L7)) + L7) * 0.0;","    fx += ((w1 * (H7 - L7)) + L7) * 0.0;","    fx += ((w2 * (H7 - L7)) + L7) * 0.0;","    fx += ((w0 * (H2 - L2)) + L2) * 1.0;","    fx += ((w1 * (H2 - L2)) + L2) * 3.0;","    fx += ((w2 * (H2 - L2)) + L2) * 1.0;","    fx += ((w0 * (H5 - L5)) + L5) * 3.0;","    fx += ((w1 * (H5 - L5)) + L5) * 6.0;","    fx += ((w2 * (H5 - L5)) + L5) * 3.0;","    fx += ((w0 * (H8 - L8)) + L8) * 1.0;","    fx += ((w1 * (H8 - L8)) + L8) * 3.0;","    fx += ((w2 * (H8 - L8)) + L8) * 1.0;","    fy =  ((w0 * (H0 - L0)) + L0) * 1.0;","    fy += ((w1 * (H0 - L0)) + L0) * 3.0;","    fy += ((w2 * (H0 - L0)) + L0) * 1.0;","    fy += ((w0 * (H3 - L3)) + L3) * 0.0;","    fy += ((w1 * (H3 - L3)) + L3) * 0.0;","    fy += ((w2 * (H3 - L3)) + L3) * 0.0;","    fy += ((w0 * (H6 - L6)) + L6) * -1.0;","    fy += ((w1 * (H6 - L6)) + L6) * -3.0;","    fy += ((w2 * (H6 - L6)) + L6) * -1.0;","    fy += ((w0 * (H1 - L1)) + L1) * 3.0;","    fy += ((w1 * (H1 - L1)) + L1) * 6.0;","    fy += ((w2 * (H1 - L1)) + L1) * 3.0;","    fy += ((w0 * (H4 - L4)) + L4) * 0.0;","    fy += ((w1 * (H4 - L4)) + L4) * 0.0;","    fy += ((w2 * (H4 - L4)) + L4) * 0.0;","    fy += ((w0 * (H7 - L7)) + L7) * -3.0;","    fy += ((w1 * (H7 - L7)) + L7) * -6.0;","    fy += ((w2 * (H7 - L7)) + L7) * -3.0;","    fy += ((w0 * (H2 - L2)) + L2) * 1.0;","    fy += ((w1 * (H2 - L2)) + L2) * 3.0;","    fy += ((w2 * (H2 - L2)) + L2) * 1.0;","    fy += ((w0 * (H5 - L5)) + L5) * 0.0;","    fy += ((w1 * (H5 - L5)) + L5) * 0.0;","    fy += ((w2 * (H5 - L5)) + L5) * 0.0;","    fy += ((w0 * (H8 - L8)) + L8) * -1.0;","    fy += ((w1 * (H8 - L8)) + L8) * -3.0;","    fy += ((w2 * (H8 - L8)) + L8) * -1.0;","    fz =  ((w0 * (H0 - L0)) + L0) * -1.0;","    fz += ((w1 * (H0 - L0)) + L0) * 0.0;","    fz += ((w2 * (H0 - L0)) + L0) * 1.0;","    fz += ((w0 * (H3 - L3)) + L3) * -3.0;","    fz += ((w1 * (H3 - L3)) + L3) * 0.0;","    fz += ((w2 * (H3 - L3)) + L3) * 3.0;","    fz += ((w0 * (H6 - L6)) + L6) * -1.0;","    fz += ((w1 * (H6 - L6)) + L6) * 0.0;","    fz += ((w2 * (H6 - L6)) + L6) * 1.0;","    fz += ((w0 * (H1 - L1)) + L1) * -3.0;","    fz += ((w1 * (H1 - L1)) + L1) * 0.0;","    fz += ((w2 * (H1 - L1)) + L1) * 3.0;","    fz += ((w0 * (H4 - L4)) + L4) * -6.0;","    fz += ((w1 * (H4 - L4)) + L4) * 0.0;","    fz += ((w2 * (H4 - L4)) + L4) * 6.0;","    fz += ((w0 * (H7 - L7)) + L7) * -3.0;","    fz += ((w1 * (H7 - L7)) + L7) * 0.0;","    fz += ((w2 * (H7 - L7)) + L7) * 3.0;","    fz += ((w0 * (H2 - L2)) + L2) * -1.0;","    fz += ((w1 * (H2 - L2)) + L2) * 0.0;","    fz += ((w2 * (H2 - L2)) + L2) * 1.0;","    fz += ((w0 * (H5 - L5)) + L5) * -3.0;","    fz += ((w1 * (H5 - L5)) + L5) * 0.0;","    fz += ((w2 * (H5 - L5)) + L5) * 3.0;","    fz += ((w0 * (H8 - L8)) + L8) * -1.0;","    fz += ((w1 * (H8 - L8)) + L8) * 0.0;","    fz += ((w2 * (H8 - L8)) + L8) * 1.0;","    vec3 n = vec3( fx/27.0 , fy/27.0 , fz/27.0 );","    return n;","}","// returns intensity of reflected ambient lighting","const vec3 lightColor = vec3(1.0, 0.88, 0.74);","const vec3 u_intensity = vec3(0.1, 0.1, 0.1);","vec3 ambientLighting()","{","    const vec3 u_matAmbientReflectance = lightColor;","    const vec3 u_lightAmbientIntensity = u_intensity;","    return u_matAmbientReflectance * u_lightAmbientIntensity;","}","// returns intensity of diffuse reflection","vec3 diffuseLighting(in vec3 N, in vec3 L)","{","    const vec3 u_matDiffuseReflectance = lightColor;","    const vec3 u_lightDiffuseIntensity = vec3(0.6, 0.6, 0.6);","    // calculation as for Lambertian reflection","    float diffuseTerm = dot(N, L);","    if (diffuseTerm > 1.0) {","        diffuseTerm = 1.0;","    } else if (diffuseTerm < 0.0) {","        diffuseTerm = 0.0;","    }","    return u_matDiffuseReflectance * u_lightDiffuseIntensity * diffuseTerm;","}","// returns intensity of specular reflection","vec3 specularLighting(in vec3 N, in vec3 L, in vec3 V)","{","  float specularTerm = 0.0;","    // const vec3 u_lightSpecularIntensity = vec3(0, 1, 0);","    const vec3 u_lightSpecularIntensity = u_intensity;","    const vec3 u_matSpecularReflectance = lightColor;","    const float u_matShininess = 5.0;","   // calculate specular reflection only if","   // the surface is oriented to the light source","   if(dot(N, L) > 0.0)","   {","      vec3 e = normalize(-V);","      vec3 r = normalize(-reflect(L, N));","      specularTerm = pow(max(dot(r, e), 0.0), u_matShininess);","   }","   return u_matSpecularReflectance * u_lightSpecularIntensity * specularTerm;","}","void main(void)","{","    const int uStepsI = 256;","    const float uStepsF = float(uStepsI);","    vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0;","    vec4 backColor = texture2D(uBackCoord,texC);","    vec3 dir = backColor.rgb - frontColor.rgb;","    vec4 vpos = frontColor;","    vec3 Step = dir/uStepsF;","    vec4 accum = vec4(0, 0, 0, 0);","    vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);","    vec4 colorValue = vec4(0, 0, 0, 0);","    float opacityFactor = uOpacityVal;","    vec3 lightPos[3];","    lightPos[0] = vec3(1, 1, 1);","    lightPos[1] = vec3(-1, -1, -1);","    lightPos[2] = vec3(1, 1, -1);","    // float xsqu;","    // float ysqu;","    // float distanceFromCenter;","    for(int i = 0; i < uStepsI; i++) {","      // xsqu = (0.5 - vpos.x) * (0.5 - vpos.x);","      // ysqu = (0.5 - vpos.y) * (0.5 - vpos.y);","      // distanceFromCenter = sqrt(xsqu + ysqu);","      //","      // if (distanceFromCenter < 0.4534 && vpos.z > 0.1 && vpos.z < 0.9) {","        vec3 gray_val = getVolumeValue(vpos.xyz);","        /************************************/","        /*         Mean filtering           */","        /************************************/","        if (gray_val.x > uMinGrayVal && gray_val.x < uMaxGrayVal) {","          float sum_gray_val = 0.0;","          int mask_size = 3;","          vec3 offset;","          vec3 curDotPos;","          for(int m_i = 0; m_i < 3; ++m_i) { // 3 = mask_size","            for(int j = 0; j < 3; ++j) {","              for(int k = 0; k < 3; ++k) {","                offset = vec3((float(m_i) - 1.0) / xw, // 1.0 = (int)mask_size / 2","                              (float(j) - 1.0) / yw,","                              (float(k) - 1.0) / zw);","                curDotPos = vpos.xyz + offset;","                sum_gray_val += getVolumeValue(curDotPos).x;","              }","            }","          }","          gray_val.x = sum_gray_val / 27.0; // 27.0 = pow(mask_size, 3)","        } // end of Mean filtering","        if(gray_val.z < 0.05 ||","           gray_val.x < uMinGrayVal ||","           gray_val.x > uMaxGrayVal)","            colorValue = vec4(0.0);","        else {","            colorValue.x = (darkness * 2.0 - gray_val.x) * l * 0.4;","            //colorValue.x = gray_val.x;","            colorValue.w = 0.1;","            if ( uSetViewMode == 1 ) {","              vec3 V = normalize(cameraPosition - vpos.xyz);","              vec3 N = normalize(getNormal(vpos.xyz));","              for(int light_i = 0; light_i < 3; ++light_i) {","                vec3 L = normalize(lightPos[light_i] - vpos.xyz);","                vec3 Iamb = ambientLighting();","                vec3 Idif = diffuseLighting(N, L);","                vec3 Ispe = specularLighting(N, L, V);","                sample.rgb += (Iamb + Idif + Ispe);","              }","              sample.a = 1.0;","            } else {","                sample.rgb = (1.0 - accum.a) * colorValue.xxx * sample.a;","                sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF);","            }","            accum += sample;","            if(accum.a>=1.0)","               break;","        }","      // }","        //advance the current position","        vpos.xyz += Step;","        if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)","            break;","    }","    gl_FragColor = accum;","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassTrilinearRGB={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uSlicemapWidth:{type:"f",value:-1},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uAbsorptionModeIndex:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},uSteps:{type:"f",value:-1},uRatio:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["varying vec3 worldSpaceCoords;","varying vec4 projectedCoords;"," ","void main()","{","    worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;","    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","    projectedCoords = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#ifdef GL_FRAGMENT_PRECISION_HIGH "," // highp is supported "," precision highp int; "," precision highp float; ","#else "," // high is not supported "," precision mediump int; "," precision mediump float; ","#endif ","// Passed from vertex","varying vec3 worldSpaceCoords; ","varying vec4 projectedCoords; ","// Passed from core","uniform sampler2D uBackCoord; ","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uSlicemapWidth;","// Assuming a bounding box of 512x512x512","// ceil( sqrt(3) * 512 ) = 887","const int MAX_STEPS = 887;","// Application specific parameters","uniform float uNumberOfSlices; ","uniform float uMinGrayVal; ","uniform float uMaxGrayVal;","uniform float uOpacityVal; ","uniform float uColorVal; ","uniform float uAbsorptionModeIndex;","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float uSteps;","uniform float uRatio;","// uniform int uAvailable_textures_number;","vec4 getVolumeValue(vec3 volpos)","{","    //if (volpos.z < 0.5)","    //    return vec4(0.0);","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    float dx2, dy2; ","    // float value; ","    vec2 texpos1,texpos2;","    float slicesPerSprite = uSlicesOverX * uSlicesOverY;","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float delta = 1.0 / (sliceSizeX * uRatio);","    ","    float adapted_x, adapted_y, adapted_z;","    //adapted_x = (volpos.x * (1.0 - (2.0*delta))) + delta;","    //adapted_y = (volpos.y * (1.0 - (2.0*delta))) + delta;","    //adapted_z = 1.0 - (( (volpos.z* (1.0/uRatio) ) * (1.0 - (2.0*delta))) + delta);","    ","    adapted_x = volpos.x;","    adapted_y = volpos.y;","    //adapted_z = volpos.z;","    adapted_z = 1.0 - (volpos.z * (1.0/uRatio));","    s1Original = floor(adapted_z * uNumberOfSlices);","    s2Original = s1Original + delta;","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    int tex2Index = int(floor(s2Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    s2 = mod(s2Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    ","    dx2 = fract(s2/uSlicesOverX);","    dy2 = floor(s2/uSlicesOverY)/uSlicesOverY;","    ","    texpos1.x = dx1+(adapted_x*sliceSizeX)/uSlicemapWidth;","    texpos1.y = dy1+(adapted_y*sliceSizeY)/uSlicemapWidth;","    ","    texpos2.x = dx2+(adapted_x*sliceSizeX)/uSlicemapWidth;","    texpos2.y = dy2+(adapted_y*sliceSizeY)/uSlicemapWidth;"," "," ","    vec4 value1, value2;","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","        if( tex2Index == <%=i%> )","        {","            value2 = texture2D(uSliceMaps[<%=i%>],texpos1).rgba;","        }","    <% } %>","    ","    //return vec4( (value1 + value2) * 0.5);","    ","    ","    return mix(value1, value2, fract(volpos.z* uNumberOfSlices));","}","float getTextureValue(int slicemapNo, vec2 texpos)","{","    float value = 0.0;","    vec3 value_vec;","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( slicemapNo == <%=i%> )","        {","          value_vec = texture2D(uSliceMaps[<%=i%>],texpos).rgb;","          //value = ((value_vec.r + value_vec.g + value_vec.b)/3.0);","          //value = ((value_vec.r * 0.299)+(value_vec.g * 0.587)+(value_vec.b * 0.114));","          value = value_vec.r;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    ","    return value;","}","float getValueTri(vec3 volpos)","{","    vec2 texpos1a, texpos1b, texpos1c, texpos1d, texpos2a, texpos2b, texpos2c, texpos2d;","    float value1a, value1b, value1c, value1d, value2a, value2b, value2c, value2d, valueS;","    float value1ab, value1cd, value1ac, value1bd, value2ab, value2cd, value2ac, value2bd, value1, value2;","    float NOS = uNumberOfSlices;  //  abbreviation ","    float slicesPerSlicemap = uSlicesOverX * uSlicesOverY; ","    float sliceSizeX = uSlicemapWidth/uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth/uSlicesOverY;  // Number of pixels of ONE slice along y axis","    ","    //  Slice selection","    float sliceNo1 = floor(abs(volpos.z*NOS-0.5));  //  sliceNo1 stands for lower slice","    float sliceNo2 = NOS-1.0-floor(abs(NOS-0.5-volpos.z*NOS));  //  sliceNo2 stands for upper slice","    int slicemapNo1 = int(floor(sliceNo1 / slicesPerSlicemap));","    int slicemapNo2 = int(floor(sliceNo2 / slicesPerSlicemap));","    float s1 = mod(sliceNo1, slicesPerSlicemap);  // s1 stands for the sliceNo of lower slice in this map","    float dx1 = fract(s1/uSlicesOverX);","    float dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    float s2 = mod(sliceNo2, slicesPerSlicemap);  // s2 stands for the sliceNo of upper slice in this map","    float dx2 = fract(s2/uSlicesOverX);","    float dy2 = floor(s2/uSlicesOverY)/uSlicesOverY;","    ","    /*","    texpos1.x = dx1+volpos.x/uSlicesOverX;  // directly from texture2D","    texpos1.y = dy1+volpos.y/uSlicesOverY;","    texpos1.x = dx1+(floor(volpos.x*sliceSizeX)+0.5)/uSlicemapWidth;  //  NearestNeighbor in lower slice","    texpos1.y = dy1+(floor(volpos.y*sliceSizeY)+0.5)/uSlicemapWidth;","    */","    ","    // Four nearest pixels in lower slice","    texpos1a.x = texpos1c.x = dx1+(floor(abs(volpos.x*sliceSizeX-0.5))+0.5)/uSlicemapWidth;  //  Trilinear","    texpos1a.y = texpos1b.y = dy1+(floor(abs(volpos.y*sliceSizeY-0.5))+0.5)/uSlicemapWidth;","    texpos1b.x = texpos1d.x = dx1+(sliceSizeX-1.0-floor(abs(sliceSizeX-0.5-volpos.x*sliceSizeX))+0.5)/uSlicemapWidth;","    texpos1c.y = texpos1d.y = dy1+(sliceSizeY-1.0-floor(abs(sliceSizeY-0.5-volpos.y*sliceSizeY))+0.5)/uSlicemapWidth;","    ","    // Four nearest pixels in upper slice","    texpos2a.x = texpos2c.x = dx2+(floor(abs(volpos.x*sliceSizeX-0.5))+0.5)/uSlicemapWidth;  //  Trilinear","    texpos2a.y = texpos2b.y = dy2+(floor(abs(volpos.y*sliceSizeY-0.5))+0.5)/uSlicemapWidth;","    texpos2b.x = texpos2d.x = dx2+(sliceSizeX-1.0-floor(abs(sliceSizeX-0.5-volpos.x*sliceSizeX))+0.5)/uSlicemapWidth;","    texpos2c.y = texpos2d.y = dy2+(sliceSizeY-1.0-floor(abs(sliceSizeY-0.5-volpos.y*sliceSizeY))+0.5)/uSlicemapWidth;","    // get texture values of these 8 pixels","    value1a = getTextureValue(slicemapNo1, texpos1a);","    value1b = getTextureValue(slicemapNo1, texpos1b);","    value1c = getTextureValue(slicemapNo1, texpos1c);","    value1d = getTextureValue(slicemapNo1, texpos1d);","    value2a = getTextureValue(slicemapNo2, texpos2a);","    value2b = getTextureValue(slicemapNo2, texpos2b);","    value2c = getTextureValue(slicemapNo2, texpos2c);","    value2d = getTextureValue(slicemapNo2, texpos2d);","    ","    // ratio calculation","    float ratioX = volpos.x*sliceSizeX+0.5-floor(volpos.x*sliceSizeX+0.5);","    float ratioY = volpos.y*sliceSizeY+0.5-floor(volpos.y*sliceSizeY+0.5);","    float ratioZ = volpos.z*NOS+0.5-floor(volpos.z*NOS+0.5);","    //float ratioZ = (volpos.z-(sliceNo1+0.5)/NOS) / (1.0/NOS);  // Another way to get ratioZ","    ","    ","    //  Trilinear interpolation ","    value1ab = value1a+ratioX*(value1b-value1a);","    value1cd = value1c+ratioX*(value1d-value1c);","    value1 = value1ab+ratioY*(value1cd-value1ab);","    value2ab = value2a+ratioX*(value2b-value2a);","    value2cd = value2c+ratioX*(value2d-value2c);","    value2 = value2ab+ratioY*(value2cd-value2ab);","    ","    valueS = value1+ratioZ*(value2-value1);","    ","    ","    // Do NO interpolation with empty voxels","    if (value1a<=0.0 || value1b<=0.0 || value1c<=0.0 || value1d<=0.0 || value2a<=0.0 || value2b<=0.0 || value2c<=0.0 || value2d<=0.0)","    {","        if (value1a<=0.0 || value1c<=0.0 || value2a<=0.0 || value2c<=0.0)","        {    ","            value1ab = value1b;","            value1cd = value1d;","            value2ab = value2b;","            value2cd = value2d;","            ","            if (value1b<=0.0 || value2b<=0.0)","            {","                value1 = value1d;","                value2 = value2d;","                ","                if (value1d <= 0.0)","                    valueS = value2;","                else if (value2d <= 0.0)","                    valueS = value1;","                else","                    valueS = value1+ratioZ*(value2-value1);","            }","            ","            else if (value1d<=0.0 || value2d<=0.0)","            {","                value1 = value1b;","                value2 = value2b;","                valueS = value1+ratioZ*(value2-value1);","            }","            ","            else","            {","                value1 = value1ab+ratioY*(value1cd-value1ab);","                value2 = value2ab+ratioY*(value2cd-value2ab);","                valueS = value1+ratioZ*(value2-value1);","            }","        }","    ","    ","        else","        {  // if (value1b<=0.0 || value1d<=0.0 || value2b<=0.0 || value2d<=0.0)","            value1ab = value1a;","            value1cd = value1c;","            value2ab = value2a;","            value2cd = value2c;","            ","            value1 = value1ab+ratioY*(value1cd-value1ab);","            value2 = value2ab+ratioY*(value2cd-value2ab);","            valueS = value1+ratioZ*(value2-value1);","        }","    ","    }","    ","    ","    /*","    if (value1a<=0.0 || value1b<=0.0 || value1c<=0.0 || value1d<=0.0 || value2a<=0.0 || value2b<=0.0 || value2c<=0.0 || value2d<=0.0)","        valueS = 0.0;","    */","    ","    return valueS;","}","void main(void) {"," ","    //Transform the coordinates it from [-1;1] to [0;1]","    vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,","                     ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0);","    //The back position is the world space position stored in the texture.","    vec3 backPos = texture2D(uBackCoord, texc).xyz;","                ","    //The front position is the world space position of the second render pass.","    vec3 frontPos = worldSpaceCoords;"," ","    //The direction from the front position to back position.","    vec3 dir = backPos - frontPos;","    float rayLength = length(dir);","    //Calculate how long to increment in each step.","    float steps = ceil( sqrt(3.0) * (uSlicemapWidth / uSlicesOverX) ) * uRatio;","    //float steps = 256.0;","    float delta = 1.0 / steps;","    ","    //The increment in each direction for each step.","    vec3 deltaDirection = normalize(dir) * delta;","    ","    vec3 Step = dir / steps;","    ","    float deltaDirectionLength = length(deltaDirection);","    //vec4 vpos = frontColor;  // currentPosition","    //vec3 Step = dir/uStepsF; // steps","    //Start the ray casting from the front position.","    vec3 currentPosition = frontPos;","    //The color accumulator.","    vec4 accumulatedColor = vec4(0.0);","    //The alpha value accumulated so far.","    float accumulatedAlpha = 0.0;","    ","    //How long has the ray travelled so far.","    float accumulatedLength = 0.0;","    ","    //If we have twice as many samples, we only need ~1/2 the alpha per sample.","    //Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.","    float alphaScaleFactor = 28.8 * delta;","    ","    vec4 colorSample = vec4(0.0);","    vec4 sample = vec4(0.0); ","    vec4 grayValue;","    float alphaSample;","    float alphaCorrection = 1.0;","    ","    float sliceSizeX = uSlicemapWidth / uSlicesOverX;  // Number of pixels of ONE slice along x axis","    float sliceSizeY = uSlicemapWidth / uSlicesOverY;  // Number of pixels of ONE slice along y axis","    float sm_delta = 1.0 / sliceSizeX;","    ","    //Perform the ray marching iterations","    for(int i = 0; i < MAX_STEPS; i++) {       ","        if(currentPosition.x > 1.0 ||","           currentPosition.y > 1.0 ||","           currentPosition.z > 1.0 ||","           currentPosition.x < 0.0 ||","           currentPosition.y < 0.0 ||","           currentPosition.z < 0.0)","            break;","        if(accumulatedColor.a>=1.0) ","            break;","        //grayValue = getVolumeValue(currentPosition);","        grayValue = vec4(getValueTri(currentPosition));","        if(grayValue.z < 0.05 || ","           grayValue.x <= uMinGrayVal ||","           grayValue.x >= uMaxGrayVal)  ","            accumulatedColor = vec4(0.0);     ","        else { ","            //colorSample.x = (1.0 * 2.0 - grayValue.x) * 5.0 * 0.4;","            colorSample.xyz = grayValue.xyz;","            //colorSample.w = alphaScaleFactor;","            colorSample.w = 0.1;","              ","            //sample.a = colorSample.a * 40.0 * (1.0 / steps);","            sample.a = colorSample.a;","            sample.rgb = (1.0 - accumulatedColor.a) * colorSample.xyz * sample.a; ","             ","            accumulatedColor += sample; ","        }    ","   ","        //Advance the ray.","        //currentPosition.xyz += deltaDirection;","        currentPosition.xyz += Step;","   ","         ","    } ","    gl_FragColor = accumulatedColor;","}"].join("\n")},window.VRC.VolumeRaycaster=function(config){var me={};return me._token,me._needRedraw=!0,me._isStart=!1,me._isChange=!1,me._clock=new THREE.Clock,me._onLoadSlicemap=new VRC.EventDispatcher,me._onLoadSlicemaps=new VRC.EventDispatcher,me._core=new VRC.Core(config),me._adaptationManager=new VRC.AdaptationManager,me.init=function(){function animate(){requestAnimationFrame(animate),me._needRedraw&&me._isStart&&me._core.draw(0)}me._core.init(),me._adaptationManager.init(me._core),me.addCallback("onCameraChange",function(){me._needRedraw=!0,me.isChange=!0}),me.addCallback("onCameraChangeStart",function(){me._needRedraw=!0,me.isChange=!0,clearInterval(me._token)}),me.addCallback("onCameraChangeEnd",function(){me._token=setInterval(function(){me._needRedraw=!1,me.isChange=!1,console.log("DEACTIVATE"),clearInterval(me._token)},5e3)}),animate()},me.setSlicemapsImages=function(images,imagesPaths){var maxTexSize=me._core.getMaxTextureSize(),maxTexturesNumber=me._core.getMaxTexturesNumber(),firstImage=images[0],imagesNumber=images.length;if(imagesNumber>maxTexturesNumber)throw Error("Number of slicemaps bigger then number of available texture units. Available texture units: "+maxTexturesNumber);if(Math.max(firstImage.width,firstImage.height)>maxTexSize||imagesNumber>maxTexturesNumber)throw Error("Size of slice bigger than maximum possible on current GPU. Maximum size of texture: "+maxTexSize);me._core.setSlicemapsImages(images,imagesPaths),me._needRedraw=!0},me.uploadSlicemapsImages=function(imagesPaths,userOnLoadImage,userOnLoadImages,userOnError){!function(imagesPaths,onLoadImage,onLoadImages,onError){var downloadedImages=[],downloadedImagesNumber=0;try{for(var imageIndex=0;imageIndex<imagesPaths.length;imageIndex++)!function(image,imageIndex){image.onload=function(){downloadedImages[imageIndex]=image,downloadedImagesNumber++,onLoadImage(image),downloadedImagesNumber==imagesPaths.length&&onLoadImages(downloadedImages)},image.onerror=onError,image.src=imagesPaths[imageIndex]}(new Image,imageIndex)}catch(e){onError(e)}}(imagesPaths,function(image){me._onLoadSlicemap.call(image),void 0!=userOnLoadImage&&userOnLoadImage(image)},function(images){me.setSlicemapsImages(images,imagesPaths),me._onLoadSlicemaps.call(images),void 0!=userOnLoadImages&&userOnLoadImages(images)},function(error){void 0!=userOnError?userOnError(error):console.error(error)})},me.start=function(){me._isStart=!0,console.log("VRC: start()")},me.stop=function(){me._isStart=!1,console.log("VRC: stop()")},me.setSteps=function(steps_number){if(!(steps_number<=me._core.getMaxStepsNumber()))throw Error("Number of steps should be lower of equal length of min volume dimension.");me._core.setSteps(steps_number),me._needRedraw=!0},me.setAutoStepsOn=function(flag){me._adaptationManager.run(flag),me._needRedraw=!0},me.setSlicesRange=function(from,to){me._core.setSlicesRange(from,to),me._needRedraw=!0},me.setMode=function(conf){me._core.setMode(conf),me._needRedraw=!0},me.isVisible=function(x0,y0,z0,x,y,z,camx,camy,camz){return me._core.isVisible(x0,y0,z0,x,y,z,camx,camy,camz),me._needRedraw=!0,me._core.isVisible()},me.calcXZ=function(xa,ya,za,xb,yb,zb){me._core.calcXZ(xa,ya,za,xb,yb,zb),me._needRedraw=!0},me.setShader=function(codeblock){me._core.setShader(codeblock),me._needRedraw=!0},me.setZoom=function(x1,x2,y1,y2){me._core.setZoom(x1,x2,y1,y2),me._needRedraw=!0},me.setOpacityFactor=function(opacity_factor){me._core.setOpacityFactor(opacity_factor),me._needRedraw=!0},me.setColorFactor=function(color_factor){me._core.setColorFactor(color_factor),me._needRedraw=!0},me.setAbsorptionMode=function(mode_index){me._core.setAbsorptionMode(mode_index),me._needRedraw=!0},me.setIndexOfImage=function(indexOfImage){me._core.setIndexOfImage(indexOfImage),me._needRedraw=!0},me.setVolumeSize=function(width,height,depth){me._core.setVolumeSize(width,height,depth),me._needRedraw=!0},me.setGeometryMinX=function(value){if(value>1||value<0)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value>me._core.getGeometryDimensions().xmax)throw Error("Min X should be lower than max X!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.xmin=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMaxX=function(value){if(value>1||value<0)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value<me._core.getGeometryDimensions().xmin)throw Error("Max X should be bigger than min X!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.xmax=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMinY=function(value){if(value>1||value<0)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value>me._core.getGeometryDimensions().ymax)throw Error("Min Y should be lower than max Y!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.ymin=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMaxY=function(value){if(value>1||value<0)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value<me._core.getGeometryDimensions().ymin)throw Error("Max Y should be bigger than min Y!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.ymax=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMinZ=function(value){if(value>1||value<0)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value>me._core.getGeometryDimensions().zmax)throw Error("Min Z should be lower than max Z!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.zmin=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMaxZ=function(value){if(value>1||value<0)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value<me._core.getGeometryDimensions().zmin)throw Error("Max Z should be bigger than min Z!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.zmax=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setRenderCanvasSize=function(width,height){me._core.setRenderCanvasSize(width,height),me._needRedraw=!0},me.showISO=function(){return me._core.showISO()},me.showVolren=function(){return me._core.showVolren()},me.showLight=function(){return me._core.showLight()},me.hideLight=function(){return me._core.hideLight()},me.startLightRotation=function(){return me._core.startLightRotation()},me.stopLightRotation=function(){return me._core.stopLightRotation()},me.setAxis=function(){me._core.setAxis(),me._needRedraw=!0},me.setStats=function(value){me._core.setStats(value),me._needRedraw=!0},me.removeWireframe=function(){me._core.removeWireframe(),me._needRedraw=!0},me.addWireframe=function(){me._core.addWireframe(),me._needRedraw=!0},me.startRotate=function(){me._core.startRotate(),me._needRedraw=!0},me.stopRotate=function(){me._core.stopRotate(),me._needRedraw=!0},me.setBackgroundColor=function(color){me._core.setBackgroundColor(color),me._needRedraw=!0},me.setScrewThreshold=function(value){me._core.setScrewThreshold(value),me._needRedraw=!0},me.setJointThreshold=function(value){me._core.setJointThreshold(value),me._needRedraw=!0},me.setL=function(value){me._core.setL(value),me._needRedraw=!0},me.setS=function(value){me._core.setS(value),me._needRedraw=!0},me.setHMin=function(value){me._core.setHMin(value),me._needRedraw=!0},me.setHMax=function(value){me._core.setHMax(value),me._needRedraw=!0},me.setMinRefl=function(value){me._core.setMinRefl(value),me._needRedraw=!0},me.setShaderName=function(value){me._core.setShaderName(value),me._needRedraw=!0},me.setSosThresholdBot=function(sosThresholdBot){me._core.setSosThresholdBot(sosThresholdBot),me._needRedraw=!0},me.setSosThresholdTop=function(sosThresholdTop){me._core.setSosThresholdTop(sosThresholdTop),me._needRedraw=!0},me.setAttenThresholdBot=function(attenThresholdBot){me._core.setAttenThresholdBot(attenThresholdBot),me._needRedraw=!0},me.setAttenThresholdTop=function(attenThresholdTop){me._core.setAttenThresholdTop(attenThresholdTop),me._needRedraw=!0},me.setMaxRefl=function(value){me._core.setMaxRefl(value),me._needRedraw=!0},me.setMaxSos=function(value){me._core.setMaxSos(value),me._needRedraw=!0},me.setMaxAtten=function(value){me._core.setMaxAtten(value),me._needRedraw=!0},me.setRowCol=function(row,col){me._core.setRowCol(row,col),me._needRedraw=!0},me.setGrayMinValue=function(value){if(value>1||value<0)throw Error("Gray value should be in range [0.0 - 1.0] !");if(value>me.getGrayMaxValue())throw Error("Gray min value should be lower than max value!");me._core.setGrayMinValue(value),me._needRedraw=!0},me.setGrayMaxValue=function(value){if(value>1||value<0)throw Error("Gray value should be in range [0.0 - 1.0] !");if(value<me.getGrayMinValue())throw Error("Gray max value should be bigger than min value!");me._core.setGrayMaxValue(value),me._needRedraw=!0},me.Axis=function(){me._core.setAxis(),me._needRedraw=!0},me.applyThresholding=function(threshold_name){me._core.applyThresholding(threshold_name),me._needRedraw=!0},me.setTransferFunctionByColors=function(colors){me._core.setTransferFunctionByColors(colors),me._needRedraw=!0},me.setTransferFunctionByImage=function(image){me._core.setTransferFunctionByImage(image),me._needRedraw=!0},me.addCallback=function(event_name,callback,needStart){switch(event_name){case"onPreDraw":return me._core.onPreDraw.add(callback,needStart);case"onPostDraw":return me._core.onPostDraw.add(callback,needStart);case"onResizeWindow":return me._core.onResizeWindow.add(callback,needStart);case"onCameraChange":return me._core.onCameraChange.add(callback,needStart);case"onCameraChangeStart":return me._core.onCameraChangeStart.add(callback,needStart);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.add(callback,needStart);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.add(callback,needStart);case"onLoadSlicemap":return me._onLoadSlicemap.add(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.add(callback,needStart)}me._needRedraw=!0},me.removeCallback=function(event_name,index){switch(event_name){case"onPreDraw":return me._core.onPreDraw.remove(index);case"onPostDraw":return me._core.onPostDraw.remove(index);case"onResizeWindow":return me._core.onResizeWindow.remove(index);case"onCameraChange":return me._core.onCameraChange.remove(index);case"onCameraChangeStart":return me._core.onCameraChangeStart.remove(index);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.remove(index);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.remove(index);case"onLoadSlicemap":return me._onLoadSlicemap.remove(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.remove(callback,needStart)}me._needRedraw=!0},me.startCallback=function(event_name,index){switch(event_name){case"onPreDraw":return me._core.onPreDraw.start(index);case"onPostDraw":return me._core.onPostDraw.start(index);case"onResizeWindow":return me._core.onResizeWindow.start(index);case"onCameraChange":return me._core.onCameraChange.start(index);case"onCameraChangeStart":return me._core.onCameraChangeStart.start(index);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.start(index);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.start(index);case"onLoadSlicemap":return me._onLoadSlicemap.start(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.start(callback,needStart)}me._needRedraw=!0},me.stopCallback=function(event_name,index){switch(event_name){case"onPreDraw":return me._core.onPreDraw.stop(index);case"onPostDraw":return me._core.onPostDraw.stop(index);case"onResizeWindow":return me._core.onResizeWindow.stop(index);case"onCameraChange":return me._core.onCameraChange.stop(index);case"onCameraChangeStart":return me._core.onCameraChangeStart.stop(index);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.stop(index);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.stop(index);case"onLoadSlicemap":return me._onLoadSlicemap.stop(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.stop(callback,needStart)}me._needRedraw=!0},me.isStartCallback=function(event_name,index){switch(event_name){case"onPreDraw":return me._core.onPreDraw.isStart(index);case"onPostDraw":return me._core.onPostDraw.isStart(index);case"onResizeWindow":return me._core.onResizeWindow.isStart(index);case"onCameraChange":return me._core.onCameraChange.isStart(index);case"onCameraChangeStart":return me._core.onCameraChangeStart.isStart(index);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.isStart(index);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.isStart(index);case"onLoadSlicemap":return me._onLoadSlicemap.isStart(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.isStart(callback,needStart)}me._needRedraw=!0},me.getGrayMaxValue=function(){return me._core.getGrayMaxValue()},me.getGrayMinValue=function(){return me._core.getGrayMinValue()},me.getSteps=function(){return me._core.getSteps()},me.getSlicesRange=function(){return me._core.getSlicesRange()},me.getRowCol=function(){return me._core.getRowCol()},me.getGrayValue=function(){return[me._core.getGrayMinValue(),me._core.getGrayMaxValue()]},me.getGeometryDimensions=function(){return me._core.getGeometryDimensions()},me.getVolumeSize=function(){return me._core.getVolumeSize()},me.getVolumeSizeNormalized=function(){return me._core.getVolumeSizeNormalized()},me.getMaxStepsNumber=function(){return me._core.getMaxStepsNumber()},me.getMaxTextureSize=function(){return me._core.getMaxTextureSize()},me.getMaxTexturesNumber=function(){return me._core.getMaxTexturesNumber()},me.getMaxFramebuferSize=function(){return me._core.getMaxFramebuferSize()},me.getOpacityFactor=function(){return me._core.getOpacityFactor()},me.getColorFactor=function(){return me._core.getColorFactor()},me.getBackground=function(){return me._core.getBackground()},me.getAbsorptionMode=function(){return me._core.getAbsorptionMode()},me.getRenderSize=function(){return me._core.getRenderSize()},me.getRenderSizeInPixels=function(){return me._core.getRenderSizeInPixels()},me.getRenderCanvasSize=function(){return me._core.getCanvasSize()},me.getRenderCavnvasSizeInPixels=function(){return me._core.getCanvasSizeInPixels()},me.getAbsorptionMode=function(){return me._core.getAbsorptionMode()},me.getSlicemapsPaths=function(){return me._core.getSlicemapsPaths()},me.getDomContainerId=function(){return me._core.getDomContainerId()},me.getCameraSettings=function(){return me._core.getCameraSettings()},me.getGeometrySettings=function(){return me._core.getGeometrySettings()},me.getDomContainerId=function(){return me._core.getDomContainerId()},me.getClearColor=function(){return me._core.getClearColor()},me.getTransferFunctionColors=function(){return me._core.getTransferFunctionColors()},me.getTransferFunctionAsImage=function(){return me._core.getTransferFunctionAsImage()},me.getBase64=function(){return me._core.getBase64()},me.set2DTexture=function(urls){return me._core.set2DTexture(urls),me._needRedraw=!0,!0},me.isAutoStepsOn=function(){return console.log("Check"),console.log(me._adaptationManager.isRun()),me._adaptationManager.isRun()},me.setAxis=function(){return me._core.setAxis()},me.draw=function(){me._core.draw()},me.setConfig=function(config,onLoadImage,onLoadImages){void 0!=config.slicemaps_images&&me.setSlicemapsImages(config.slicemaps_images),void 0!=config.slicemaps_paths&&me.uploadSlicemapsImages(config.slicemaps_paths,function(image){void 0!=onLoadImage&&onLoadImage(image)},function(images){void 0!=config.slices_range&&me.setSlicesRange(config.slices_range[0],config.slices_range[1]),me.stop(),void 0!=onLoadImages&&onLoadImages(images),me.start()}),void 0!=config.slices_range&&me.setSlicesRange(config.slices_range[0],config.slices_range[1]),void 0!=config.steps&&me._core.setSteps(config.steps),void 0!=config.row_col&&me._core.setRowCol(config.row_col[0],config.row_col[1]),void 0!=config.gray_min&&me._core.setGrayMinValue(config.gray_min),void 0!=config.gray_max&&me._core.setGrayMaxValue(config.gray_max),void 0!=config.threshold_indexes&&me._core.setThresholdIndexes(config.threshold_indexes.otsu,config.threshold_indexes.isodata,config.threshold_indexes.yen,config.threshold_indexes.li),void 0!=config.volume_size&&me.setVolumeSize(config.volume_size[0],config.volume_size[1],config.volume_size[2]),void 0!=config.x_min&&me.setGeometryMinX(config.x_min),void 0!=config.x_max&&me.setGeometryMaxX(config.x_max),void 0!=config.y_min&&me.setGeometryMinY(config.y_min),void 0!=config.y_max&&me.setGeometryMaxY(config.y_max),void 0!=config.z_min&&me.setGeometryMinZ(config.z_min),void 0!=config.z_max&&me.setGeometryMaxZ(config.z_max),void 0!=config.opacity_factor&&me._core.setOpacityFactor(config.opacity_factor),void 0!=config.color_factor&&me._core.setColorFactor(config.color_factor),void 0!=config.tf_colors&&me._core.setTransferFunctionByColors(config.tf_colors),void 0!=config.background&&me._core.setBackgroundColor(config.background),void 0!=config.auto_steps&&me.setAutoStepsOn(config.auto_steps),void 0!=config.axis&&me.setAxis(config.axis),void 0!=config.absorption_mode&&me._core.setAbsorptionMode(config.absorption_mode),void 0!=config.indexOfImage&&me._core.setIndexOfImage(config.indexOfImage),void 0!=config.render_canvas_size&&me.setRenderCanvasSize(config.render_canvas_size[0],config.render_canvas_size[1]),void 0!=config.sosThresholdBot&&me._core.setSosThresholdBot(config.sosThresholdBot),void 0!=config.sosThresholdTop&&me._core.setSosThresholdTop(config.sosThresholdTop),void 0!=config.attenThresholdBot&&me._core.setAttenThresholdBot(config.attenThresholdBot),void 0!=config.attenThresholdTop&&me._core.setAttenThresholdTop(config.attenThresholdTop),me._needRedraw=!0},me.uploadConfig=function(path,onLoad,onError){var xmlhttp;(xmlhttp=window.XMLHttpRequest?new XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP")).onreadystatechange=function(){if(xmlhttp.readyState==XMLHttpRequest.DONE)if(200==xmlhttp.status){var config=JSON.parse(xmlhttp.responseText);me.setConfig(config),void 0!=onLoad&&onLoad()}else xmlhttp.status,void 0!=userOnError&&userOnError(xmlhttp)},xmlhttp.open("GET",path,!0),xmlhttp.send()},me.getConfig=function(){return{steps:me.getSteps(),slices_range:me.getSlicesRange(),volume_size:me.getVolumeSize(),row_col:me.getRowCol(),gray_min:me.getGrayMinValue(),gray_max:me.getGrayMaxValue(),slicemaps_paths:me.getSlicemapsPaths(),opacity_factor:me.getOpacityFactor(),color_factor:me.getColorFactor(),absorption_mode:me.getAbsorptionMode(),render_size:me.getRenderSize(),render_canvas_size:me.getRenderCanvasSize(),backgound:me.getClearColor(),tf_path:me.getTransferFunctionAsImage().src,tf_colors:me.getTransferFunctionColors(),x_min:me.getGeometryDimensions().xmin,x_max:me.getGeometryDimensions().xmax,y_min:me.getGeometryDimensions().ymin,y_max:me.getGeometryDimensions().ymax,z_min:me.getGeometryDimensions().zmin,z_max:me.getGeometryDimensions().zmax,dom_container_id:me.getDomContainerId(),auto_steps:me.isAutoStepsOn(),axis:!0}},me.init(),me.setConfig(config),me};